<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0A0B2F">
    <meta name="description" content="星空探險家 - 互動式幾何學習遊戲，連接星點形成各種幾何形狀星座">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="星空探險家">
    <title>星空探險家 - 幾何學習</title>
    <link rel="manifest" href="#manifest">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNCI+PHJlY3Qgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIgZmlsbD0iIzBBMEIyRiIvPjxwYXRoIGQ9Ik03NjggNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek0yNTYgNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek01MTIgNDQ4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2eiIgZmlsbD0iI0ZGRDcwMCIvPjxwYXRoIGQ9Ik03NjggNTc2YzE4IDAgMzYgMiA1MyA2TDUxMiAyODhjLTEzIDI1LTM0IDQ2LTU5IDU5bDMwOSAyMzVjMS0yIDMtNCA1LTZtMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PHBhdGggZD0iTTQ1OSA0NDhsLTIwMyAyMjRjMjUgMTMgNDYgMzQgNTkgNTlsMjA0LTIyNGMtMjYtMTMtNDgtMzUtNjAtNTltMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PC9zdmc+">
    <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVR4nO3dMUrFQBRA0VdYiYWtpZ/1rEopWLgk38w5+1CBeyHVJQAAAAAAAMDhXa73t+nzfBjAj/l4BAEZ8/EoAjLm41EEZGQ+HkRAZjweRUBGQB5EQGbm43EEZATkQQRkZj4eR0BGQB5EQGbm45EEZMR8PI6AzMzHIwnIzHw8koCMgDyMgIyYj8cRkJn5eCQBGTEfjyMgIyAPI4sMgIAICJhAYQKFCRQ20ljDnBzmDXP2f/wbCUiI+XgcAZkz78/zCEicen9OnUBn35+z79+ZbV6hNq9Qq1eozSvUeXPb5hXKBGrzCmUDtXmFsrVt8wplArU5gdpMoDavULbWNhOozQRqM4HaTKA2EwiAX/M3EJARkAcRkJERkEcRkBHz8TgCMgLyIAIyMx+PIyAjIA8iIDPz8TgCMgLyIAIyMx+PJCAj5uNxBGRmPh5JQGbm45EEZMR8PI6AjIA8jAkUAAAAAAAAAGx8AdzN3SPw43TFAAAAAElFTkSuQmCC">
    <style>
        body {
            background-color: #0A0B2F;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .shape-selector {
            margin-bottom: 20px;
        }
        
        .shape-selector p {
            margin-bottom: 10px;
        }
        
        .shape-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        .shape-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .shape-option input {
            margin-right: 8px;
        }
        
        .shape-name {
            font-size: 16px;
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
            color: #64FFDA;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #0B0E2E, #1A1B4B);
            border-radius: 8px;
            margin: 0 auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #2A2A6A;
            position: relative;
        }
        
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: linear-gradient(135deg, #5D5CDE, #4240B3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(93, 92, 222, 0.4);
        }
        
        button:hover {
            background: linear-gradient(135deg, #6E6DFF, #5250C4);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(93, 92, 222, 0.4);
        }
        
        #checkBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 12px 25px;
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
        }
        
        #checkBtn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(100, 255, 218, 0.5);
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            font-size: 0.8rem;
            padding: 8px 12px;
        }
        
        #hintVisualBtn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.7), rgba(230, 190, 0, 0.7));
            color: #0A0B2F;
        }
        
        #hintVisualBtn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(230, 190, 0, 0.9));
        }
        
        #info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.2), rgba(93, 92, 222, 0.1));
            border-radius: 10px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(93, 92, 222, 0.3);
        }

        #task {
            font-weight: bold;
            color: #64FFDA;
            margin-bottom: 15px;
            line-height: 1.5;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.3);
        }

        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.8));
            padding: 8px 15px;
            border-radius: 20px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64FFDA;
            display: none;
        }

        #hintBox {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1), rgba(100, 255, 218, 0.05));
            border-radius: 8px;
            display: none;
            border: 1px solid rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.1);
        }
        
        .score-container {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #scoreDisplay, #streakDisplay, #highScoreDisplay {
            display: block;
            margin: 3px 0;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #streakDisplay {
            color: #FFD700;
        }
        
        .timer-container {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #timerDisplay {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        .pulse-animation {
            animation: pulse-effect 0.5s;
        }
        
        @keyframes pulse-effect {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-message {
            padding: 12px 20px;
            border-radius: 10px;
            margin-top: 15px;
            display: inline-block;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .result-success {
            background: linear-gradient(135deg, rgba(100, 255, 128, 0.2), rgba(80, 235, 108, 0.2));
            color: #64FFDA;
            border: 1px solid rgba(100, 255, 128, 0.3);
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
        }
        
        .result-fail {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(235, 80, 80, 0.2));
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow: hidden;
        }
        
        #startScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        @keyframes stars-animation {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #startScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #startScreen p {
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.8;
            font-size: 18px;
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #startGameBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        #resultScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
        }
        
        #resultScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        #resultScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #resultScreen p {
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        #finalScore {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            margin: 30px 0 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }
        
        /* 成就系統相關樣式 */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(20, 20, 50, 0.6));
            margin: 5px;
            position: relative;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .achievement-badge.unlocked {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(20, 80, 100, 0.3));
            border: 2px solid rgba(100, 255, 218, 0.8);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
            opacity: 1;
            transform: scale(1.05);
        }
        
        .achievement-badge.new-unlock {
            animation: badge-pulse 1.5s infinite alternate;
        }
        
        @keyframes badge-pulse {
            0% { transform: scale(1.05); box-shadow: 0 0 15px rgba(100, 255, 218, 0.5); }
            100% { transform: scale(1.15); box-shadow: 0 0 25px rgba(100, 255, 218, 0.8); }
        }
        
        .achievement-badge .icon {
            font-size: 28px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        .achievement-badge.locked .icon {
            color: rgba(255, 255, 255, 0.4);
            text-shadow: none;
        }
        
        .achievement-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 50, 0.9));
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .achievement-badge:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-popup {
            position: fixed;
            top: 15%;
            right: 10px;
            transform: translateX(100%) scale(0.5);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(20, 20, 80, 0.8));
            padding: 10px 15px;
            border-radius: 12px;
            z-index: 1000;
            text-align: center;
            border: 1px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 200px;
        }
        
        .achievement-popup.show {
            opacity: 0.9;
            transform: translateX(0) scale(1);
        }
        
        .achievement-popup-title {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .achievement-popup-desc {
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .achievement-icon-large {
            font-size: 28px;
            margin: 5px 0;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: achievement-spin 1.5s ease-out;
        }
        
        @keyframes achievement-spin {
            0% { transform: scale(0.5) rotate(-30deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        #achievementsSummary {
            margin-top: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 80, 0.3), rgba(20, 20, 50, 0.2));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        #achievementsSummary h3 {
            font-size: 22px;
            color: #64FFDA;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        #playAgainBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #playAgainBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        .difficulty-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.6), rgba(66, 64, 179, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-row {
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s;
        }
        
        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sound-toggle input {
            margin-right: 8px;
        }
        
        /* Star */
        .star {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                        0 0 20px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .star-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            pointer-events: none;
            opacity: 0;
            animation: star-pulse 2s infinite alternate;
        }
        
        @keyframes star-pulse {
            0% { opacity: 0.1; transform: scale(0.8); }
            100% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Line effect */
        .constellation-line {
            position: absolute;
            background: linear-gradient(90deg, 
                rgba(100, 255, 218, 0) 0%, 
                rgba(100, 255, 218, 0.8) 50%, 
                rgba(100, 255, 218, 0) 100%);
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
            opacity: 0;
            animation: line-appear 0.5s forwards;
        }
        
        @keyframes line-appear {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particles */
        .particle {
            position: absolute;
            background-color: rgba(100, 255, 218, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        /* Floating stars background */
        .bg-stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        
        .bg-star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 4s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .shooting-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.8) 50%, 
                rgba(255, 255, 255, 0) 100%);
            transform: rotate(-45deg);
            animation: shooting 3s linear forwards;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        @keyframes shooting {
            from {
                transform: translateX(0) translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            to {
                transform: translateX(500px) translateY(500px) rotate(-45deg) scale(0.1);
                opacity: 0;
            }
        }
        
        @media (max-width: 500px) {
            button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            #checkBtn {
                padding: 10px 20px;
                font-size: 1rem;
            }
            
            .score-container, .timer-container {
                padding: 3px 10px;
            }
            
            #timerDisplay {
                font-size: 16px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            #task {
                font-size: 16px;
            }
            
            #startScreen h2, #resultScreen h2 {
                font-size: 28px;
            }
            
            #finalScore {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="bg-stars" id="bgStars"></div>
    
    <div id="startScreen">
        <h2>星空探險家 - 計時挑戰模式</h2>
        <p>在1分鐘內完成盡可能多的星座幾何挑戰！<br>連接星點，形成指定類型的幾何星座圖形。</p>
        
        <div class="shape-selector">
            <p>選擇星座類型：</p>
            <div class="shape-options">
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="triangles" checked>
                    <span class="shape-name">只玩三角形星座</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="quadrilaterals">
                    <span class="shape-name">只玩四邊形星座</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="all">
                    <span class="shape-name">全部星座形狀</span>
                </label>
            </div>
        </div>
        
        <div class="settings-row">
            <label class="sound-toggle">
                <input type="checkbox" id="soundToggle" checked>
                星空音效
            </label>
        </div>
        <button id="startGameBtn">開始探索之旅</button>
    </div>

    <div id="resultScreen">
        <h2>星空探險結束！</h2>
        <p>你在1分鐘內完成了：</p>
        <div id="finalScore">0 個星座</div>
        <p>總分：<span id="finalTotalScore">0</span></p>
        
        <div id="achievementsSummary">
            <h3>解鎖的星空探險家徽章</h3>
            <div id="achievementsContainer" class="achievement-container"></div>
        </div>
        
        <button id="playAgainBtn">再次探索</button>
    </div>
    
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon-large">✨</div>
        <div class="achievement-popup-title">解鎖成就！</div>
        <div class="achievement-popup-desc">你獲得了一枚新徽章</div>
    </div>

    <h1>星空探險家 - 星座幾何學習</h1>
    
    <div id="task">請連接星點，形成一個等腰三角形星座</div>
    
    <div style="position: relative;">
        <div class="timer-container">
            <div id="timerDisplay">01:00</div>
        </div>
        <div class="score-container">
            <span id="scoreDisplay">分數: 0</span>
            <span id="streakDisplay">連勝: 0</span>
            <span id="solvedDisplay">已解題: 0</span>
            <span id="difficultyDisplay">難度: 普通</span>
        </div>
        <canvas id="gameCanvas" width="450" height="450"></canvas>
        <div id="tooltip" class="tooltip">點擊此星點開始連線</div>
    </div>
    
    <div id="controls">
        <button id="resetBtn" class="secondary-btn">重置星點</button>
        <button id="checkBtn">檢查星座</button>
        <button id="hintTextBtn" class="secondary-btn">星座提示</button>
        <button id="hintVisualBtn" class="secondary-btn">視覺幫助</button>
    </div>
    
    <div id="info">
        <p id="shapeInfo">連接閃耀的星點，形成指定類型的三角形星座</p>
        <p id="status">已連接: 0 條線 (需要連接 2 條線)</p>
        <div id="hintBox"></div>
        <div id="resultMessage" class="result-message" style="display: none;"></div>
    </div>
    
    <script>
        // 獲取Canvas元素和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const hintBox = document.getElementById('hintBox');
        const resultMessage = document.getElementById('resultMessage');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const timerDisplay = document.getElementById('timerDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const soundToggle = document.getElementById('soundToggle');
        const shapeInfo = document.getElementById('shapeInfo');
        const bgStars = document.getElementById('bgStars');
        
        // 背景星星生成
        function createBackgroundStars() {
            const starCount = Math.floor(window.innerWidth * window.innerHeight / 1000);
            bgStars.innerHTML = '';
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'bg-star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                const size = Math.random() * 2;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // 不同的閃爍時間
                star.style.animationDelay = `${Math.random() * 4}s`;
                star.style.animationDuration = `${2 + Math.random() * 3}s`;
                
                // 不同的亮度
                star.style.opacity = 0.3 + Math.random() * 0.7;
                
                bgStars.appendChild(star);
            }
            
            // 添加流星
            createShootingStar();
        }
        
        // 流星效果
        function createShootingStar() {
            if (!document.body.contains(bgStars)) return;
            
            const star = document.createElement('div');
            star.className = 'shooting-star';
            
            // 隨機位置和大小
            star.style.left = `${Math.random() * 30}%`;
            star.style.top = `${Math.random() * 20}%`;
            star.style.width = `${80 + Math.random() * 120}px`;
            
            bgStars.appendChild(star);
            
            // 動畫結束後移除
            setTimeout(() => {
                if (star.parentNode) {
                    star.parentNode.removeChild(star);
                }
                // 隨機時間後再次出現
                setTimeout(createShootingStar, 5000 + Math.random() * 15000);
            }, 3000);
        }
        
        // 遊戲設置
        let selectedShapeType = "triangles"; // 默認為三角形
        let debugMode = false; // 可在控制台設為true以顯示更多信息
        let lenientMode = true; // 較寬鬆的形狀檢測，因為我們不應該太嚴格
        
        // 音效系統 - 使用Web Audio API合成音效
        let audioContext;
        
        // 特效參數
        let stars = [];
        let particles = [];
        let constellationLines = [];
        
        // 初始化音效系統
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.warn('Web Audio API not supported:', e);
            }
        }
        
        // 播放音效
        function playSound(type) {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // 建立音效節點
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // 連接節點
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // 設置不同類型的音效參數
                switch(type) {
                    case 'correct':
                        // 正確音效 - 上升音
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);  // C5
                        oscillator.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.15); // G5
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'wrong':
                        // 錯誤音效 - 下降音
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime);  // G4
                        oscillator.frequency.linearRampToValueAtTime(261.63, audioContext.currentTime + 0.2); // C4
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'connect':
                        // 連接音效 - 短促清脆
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.05); // G5
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    
                    case 'click':
                        // 點擊音效 - 非常短促
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880.00, audioContext.currentTime); // A5
                        oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime + 0.03); // B5
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.08);
                        break;
                        
                    case 'hint':
                        // 提示音效 - 神秘的三和弦
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
            } catch(e) {
                console.warn('Error playing sound:', e);
            }
        }
        
        // 網格設置
        const gridSize = 50; // 每個格子的大小
        const numRows = 8;   // 行數
        const numCols = 8;   // 列數
        const offsetX = 25;  // X偏移（使網格從邊緣開始）
        const offsetY = 25;  // Y偏移

        // 遊戲狀態
        let selectedPoint = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isComplete = false;
        let currentLevelIndex = 0;
        let hoveredPoint = null;
        
        // 計分系統
        let score = 0;
        let streak = 0;  // 連勝
        let solvedCount = 0; // 已解題數
        
        // 成就系統
        const achievements = [
            { id: 'novice', level: 1, name: '星際新手', description: '完成第一個星座', icon: '🌟', unlocked: false },
            { id: 'connector', level: 2, name: '星點連接者', description: '完成2個星座', icon: '⭐', unlocked: false },
            { id: 'seeker', level: 3, name: '星座追尋者', description: '完成3個星座', icon: '✨', unlocked: false },
            { id: 'observer', level: 4, name: '夜空觀察家', description: '完成4個星座', icon: '🔭', unlocked: false },
            { id: 'apprentice', level: 5, name: '天文學徒', description: '完成5個星座', icon: '📚', unlocked: false },
            { id: 'ancient', level: 6, name: '古代天文師', description: '完成6個星座', icon: '🏛️', unlocked: false },
            { id: 'interpreter', level: 7, name: '星象解讀師', description: '完成7個星座', icon: '🧙', unlocked: false },
            { id: 'master', level: 8, name: '星空探險大師', description: '完成8個星座', icon: '👑', unlocked: false }
        ];
        let newUnlocks = [];
        
        // 計時系統
        let timeLeft = 60; // 60秒
        let timerInterval;
        let isGameActive = false;
        
        // 難度系統
        let currentDifficulty = "普通"; // 普通, 困難
        
        // 點的大小
        const pointRadius = 7;
        
        // 用戶連接的線
        let userLines = [];
        
        // 粒子效果相關
        let animationFrameId = null;
        
        // 三角形關卡定義
        const triangleLevels = [
            // 等邊三角形系列 - 精確計算的網格點
            {
                name: "等邊三角形",
                description: "請連接星點，形成一個等邊三角形星座",
                hint: "等邊三角形有三條邊相等，每個內角都是60度。",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 5, col: 3}, to: {row: 5, col: 5}}, // 水平線
                solutionPoint: {row: 3, col: 4}, // 精確的等邊三角形頂點
                congratsMessage: "做得好！你成功創建了一個等邊三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "等邊三角形",
                description: "請連接星點，形成一個等邊三角形星座",
                hint: "等邊三角形有三條邊相等，每個內角都是60度。",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 7, col: 5}}, // 斜線
                solutionPoint: {row: 5, col: 1}, // 精確的等邊三角形頂點
                congratsMessage: "做得好！你成功創建了一個等邊三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "等邊三角形",
                description: "請連接星點，形成一個等邊三角形星座",
                hint: "等邊三角形有三條邊相等，每個內角都是60度。",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // 水平線
                solutionPoint: {row: 1, col: 4}, // 精確的等邊三角形頂點
                congratsMessage: "做得好！你成功創建了一個等邊三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // 等腰三角形系列 - 多種預設線
            {
                name: "等腰三角形",
                description: "請連接星點，形成一個等腰三角形星座",
                hint: "等腰三角形有兩條邊相等，請找到與藍色線兩端等距離的點。",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // 水平線
                solutionPoint: {row: 2, col: 4}, // 確定的解
                congratsMessage: "太棒了！你成功創建了一個等腰三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "等腰三角形",
                description: "請連接星點，形成一個等腰三角形星座",
                hint: "等腰三角形有兩條邊相等，請找到與藍色線兩端等距離的點。",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 6}}, // 對角線
                solutionPoint: {row: 6, col: 2}, // 確定的解
                congratsMessage: "太棒了！你成功創建了一個等腰三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "等腰三角形",
                description: "請連接星點，形成一個等腰三角形星座",
                hint: "等腰三角形有兩條邊相等，請找到與藍色線兩端等距離的點。",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // 斜線
                solutionPoint: {row: 2, col: 6}, // 確定的解
                congratsMessage: "太棒了！你成功創建了一個等腰三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // 直角三角形系列 - 畢氏三元數
            {
                name: "直角三角形",
                description: "請連接星點，形成一個直角三角形星座",
                hint: "直角三角形有一個角是90度，找到使兩條邊垂直的點。",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // 水平線
                solutionPoint: {row: 6, col: 6}, // 3:4:5三元數
                congratsMessage: "非常好！你成功創建了一個直角三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "直角三角形",
                description: "請連接星點，形成一個直角三角形星座",
                hint: "直角三角形有一個角是90度，找到使兩條邊垂直的點。",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 4, col: 5}}, // 水平線
                solutionPoint: {row: 1, col: 5}, // 3:4:5三元數
                congratsMessage: "非常好！你成功創建了一個直角三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "直角三角形",
                description: "請連接星點，形成一個直角三角形星座",
                hint: "直角三角形有一個角是90度，找到使兩條邊垂直的點。",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 6, col: 6}}, // 斜線
                solutionPoint: {row: 7, col: 2}, // 5:12:13三元數變體
                congratsMessage: "非常好！你成功創建了一個直角三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // 直角等腰三角形系列
            {
                name: "直角等腰三角形",
                description: "請連接星點，形成一個直角等腰三角形星座",
                hint: "直角等腰三角形有一個角是90度，另外兩條邊相等。",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // 水平線
                solutionPoint: {row: 7, col: 3}, // 完美的直角等腰解
                congratsMessage: "太厲害了！你成功創建了一個直角等腰三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "直角等腰三角形",
                description: "請連接星點，形成一個直角等腰三角形星座",
                hint: "直角等腰三角形有一個角是90度，另外兩條邊相等。",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // 垂直線
                solutionPoint: {row: 6, col: 6}, // 完美的直角等腰解
                congratsMessage: "太厲害了！你成功創建了一個直角等腰三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "直角等腰三角形",
                description: "請連接星點，形成一個直角等腰三角形星座",
                hint: "直角等腰三角形有一個角是90度，另外兩條邊相等。",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 1, col: 4}}, // 斜線
                solutionPoint: {row: 4, col: 4}, // 完美的直角等腰解
                congratsMessage: "太厲害了！你成功創建了一個直角等腰三角形星座！",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // 不等邊三角形系列
            {
                name: "不等邊三角形",
                description: "請連接星點，形成一個不等邊三角形星座",
                hint: "不等邊三角形的三條邊長度各不相同。",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // 斜線
                solutionPoint: {row: 6, col: 2}, // 確保所有邊不等長
                congratsMessage: "優秀！你成功創建了一個不等邊三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "不等邊三角形",
                description: "請連接星點，形成一個不等邊三角形星座",
                hint: "不等邊三角形的三條邊長度各不相同。",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 6}}, // 斜線
                solutionPoint: {row: 7, col: 3}, // 確保所有邊不等長
                congratsMessage: "優秀！你成功創建了一個不等邊三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "不等邊三角形",
                description: "請連接星點，形成一個不等邊三角形星座",
                hint: "不等邊三角形的三條邊長度各不相同。",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 4, col: 4}, to: {row: 4, col: 7}}, // 水平線
                solutionPoint: {row: 1, col: 2}, // 確保所有邊不等長
                congratsMessage: "優秀！你成功創建了一個不等邊三角形星座！",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            }
        ];
        
        // 四邊形關卡定義 - 已移除所有梯形相關關卡
        const quadrilateralLevels = [
            // 正方形系列
            {
                name: "正方形",
                description: "請連接星點，形成一個正方形星座",
                hint: "正方形有四條邊相等，四個角都是90度。",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // 水平線
                solutionPoints: [{row: 6, col: 2}, {row: 6, col: 6}], // 正方形的另外兩個點
                congratsMessage: "太棒了！你成功創建了一個正方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "正方形",
                description: "請連接星點，形成一個正方形星座",
                hint: "正方形有四條邊相等，四個角都是90度。",
                checkFunction: isSquare,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // 水平線
                solutionPoints: [{row: 7, col: 3}, {row: 7, col: 7}], // 正方形的另外兩個點
                congratsMessage: "太棒了！你成功創建了一個正方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "正方形",
                description: "請連接星點，形成一個正方形星座",
                hint: "正方形有四條邊相等，四個角都是90度。",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // 垂直線
                solutionPoints: [{row: 2, col: 6}, {row: 6, col: 6}], // 正方形的另外兩個點
                congratsMessage: "太棒了！你成功創建了一個正方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // 長方形系列
            {
                name: "長方形",
                description: "請連接星點，形成一個長方形星座",
                hint: "長方形有四個角都是90度，對邊相等。",
                checkFunction: isRectangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 7}}, // 水平線
                solutionPoints: [{row: 5, col: 2}, {row: 5, col: 7}], // 長方形的另外兩個點
                congratsMessage: "很好！你成功創建了一個長方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "長方形",
                description: "請連接星點，形成一個長方形星座",
                hint: "長方形有四個角都是90度，對邊相等。",
                checkFunction: isRectangle,
                presetLine: {from: {row: 1, col: 1}, to: {row: 6, col: 1}}, // 垂直線
                solutionPoints: [{row: 1, col: 4}, {row: 6, col: 4}], // 長方形的另外兩個點
                congratsMessage: "很好！你成功創建了一個長方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "長方形",
                description: "請連接星點，形成一個長方形星座",
                hint: "長方形有四個角都是90度，對邊相等。",
                checkFunction: isRectangle,
                presetLine: {from: {row: 3, col: 1}, to: {row: 3, col: 7}}, // 水平線
                solutionPoints: [{row: 7, col: 1}, {row: 7, col: 7}], // 長方形的另外兩個點
                congratsMessage: "很好！你成功創建了一個長方形星座！",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // 平行四邊形系列
            {
                name: "平行四邊形",
                description: "請連接星點，形成一個平行四邊形星座",
                hint: "平行四邊形有兩組平行的對邊，對邊相等。",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 3, col: 2}, to: {row: 3, col: 6}}, // 水平線
                solutionPoints: [{row: 6, col: 4}, {row: 6, col: 8}], // 平行四邊形的另外兩個點
                congratsMessage: "出色！你成功創建了一個平行四邊形星座！",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "平行四邊形",
                description: "請連接星點，形成一個平行四邊形星座",
                hint: "平行四邊形有兩組平行的對邊，對邊相等。",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 2}}, // 垂直線
                solutionPoints: [{row: 3, col: 6}, {row: 6, col: 6}], // 平行四邊形的另外兩個點
                congratsMessage: "出色！你成功創建了一個平行四邊形星座！",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "平行四邊形",
                description: "請連接星點，形成一個平行四邊形星座",
                hint: "平行四邊形有兩組平行的對邊，對邊相等。",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // 水平線
                solutionPoints: [{row: 5, col: 4}, {row: 5, col: 8}], // 平行四邊形的另外兩個點
                congratsMessage: "出色！你成功創建了一個平行四邊形星座！",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            }
        ];
        
        // 合併所有關卡
        let levels = [...triangleLevels];
        let currentLevels = [...triangleLevels]; // 當前使用的關卡集
        
        // 動畫循環
        function animate() {
            // 更新粒子
            updateParticles();
            
            // 繼續動畫循環
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // 更新粒子
        function updateParticles() {
            // 更新粒子位置和生命週期
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // 更新位置
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // 更新生命
                particle.life -= 0.02;
                
                // 如果粒子死亡，移除
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                } else {
                    // 更新透明度
                    particle.element.style.opacity = particle.life;
                    
                    // 更新位置
                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;
                }
            }
            
            // 更新星星閃爍效果
            for (const star of stars) {
                if (Math.random() < 0.005) {
                    const originalScale = parseFloat(star.element.getAttribute('data-scale') || 1);
                    const newScale = originalScale * (0.8 + Math.random() * 0.4);
                    star.element.style.transform = `scale(${newScale})`;
                    
                    setTimeout(() => {
                        if (star.element.parentNode) {
                            star.element.style.transform = `scale(${originalScale})`;
                        }
                    }, 300 + Math.random() * 700);
                }
            }
        }
        
        // 創建星星效果
        function createStar(x, y, size = 3, container = document.body) {
            // 創建星星
            const star = document.createElement('div');
            star.className = 'star';
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${x}px`;
            star.style.top = `${y}px`;
            star.setAttribute('data-scale', '1');
            
            // 創建發光效果
            const glow = document.createElement('div');
            glow.className = 'star-glow';
            glow.style.width = `${size * 6}px`;
            glow.style.height = `${size * 6}px`;
            glow.style.left = `${x - size * 2.5}px`;
            glow.style.top = `${y - size * 2.5}px`;
            
            // 隨機閃爍時間
            glow.style.animationDelay = `${Math.random() * 2}s`;
            
            // 添加到容器
            container.appendChild(star);
            container.appendChild(glow);
            
            return {
                element: star,
                glow: glow,
                x: x,
                y: y,
                size: size
            };
        }
        
        // 創建粒子
        function createParticle(x, y, color = '#64FFDA') {
            const size = 1 + Math.random() * 2;
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            document.body.appendChild(particle);
            
            // 粒子屬性
            const particleObj = {
                element: particle,
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: size,
                life: 1 // 從1減少到0
            };
            
            particles.push(particleObj);
            return particleObj;
        }
        
        // 創建連接線效果
        function createConstellationLine(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            const line = document.createElement('div');
            line.className = 'constellation-line';
            line.style.width = `${length}px`;
            line.style.left = `${fromX}px`;
            line.style.top = `${fromY}px`;
            line.style.transform = `rotate(${angle}rad)`;
            
            document.body.appendChild(line);
            
            // 在線條上添加粒子效果
            const particleCount = Math.max(5, Math.floor(length / 20));
            for (let i = 0; i < particleCount; i++) {
                const ratio = Math.random();
                const x = fromX + dx * ratio;
                const y = fromY + dy * ratio;
                createParticle(x, y, 'rgba(100, 255, 218, 0.8)');
            }
            
            constellationLines.push(line);
            return line;
        }
        
        // 清除效果元素
        function clearEffects() {
            // 清除星星
            stars.forEach(star => {
                if (star.element.parentNode) star.element.parentNode.removeChild(star.element);
                if (star.glow.parentNode) star.glow.parentNode.removeChild(star.glow);
            });
            stars = [];
            
            // 清除粒子
            particles.forEach(particle => {
                if (particle.element.parentNode) 
                    particle.element.parentNode.removeChild(particle.element);
            });
            particles = [];
            
            // 清除連接線
            constellationLines.forEach(line => {
                if (line.parentNode) line.parentNode.removeChild(line);
            });
            constellationLines = [];
            
            // 取消動畫
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // 創建連接線
        function createConnectionLine(fromPoint, toPoint) {
            // 計算網格尺寸比例和座標
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            const fromX = offsetX + fromPoint.col * gridSize * gridRatio;
            const fromY = offsetY + fromPoint.row * gridSize * gridRatio;
            const toX = offsetX + toPoint.col * gridSize * gridRatio;
            const toY = offsetY + toPoint.row * gridSize * gridRatio;
            
            // 獲取Canvas相對於視窗的位置
            const rect = canvas.getBoundingClientRect();
            
            // 創建連接線效果
            createConstellationLine(
                rect.left + fromX, 
                rect.top + fromY, 
                rect.left + toX, 
                rect.top + toY
            );
            
            // 在線路上生成粒子效果
            const particleCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const ratio = i / (particleCount - 1);
                    const x = rect.left + fromX + (toX - fromX) * ratio;
                    const y = rect.top + fromY + (toY - fromY) * ratio;
                    createParticle(x, y);
                }, i * 50);
            }
        }
        
        // 初始化遊戲
        function init() {
            // 初始化音效
            initAudio();
            
            // 創建背景星星
            createBackgroundStars();
            
            // 啟動動畫循環
            animate();
            
            // 添加事件監聽器
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('playAgainBtn').addEventListener('click', restartGame);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // 按鈕事件
            document.getElementById('resetBtn').addEventListener('click', resetLines);
            document.getElementById('checkBtn').addEventListener('click', checkShape);
            document.getElementById('hintTextBtn').addEventListener('click', toggleTextHint);
            document.getElementById('hintVisualBtn').addEventListener('click', showVisualHint);
            
            // 形狀選擇事件
            const shapeOptions = document.querySelectorAll('input[name="shapeType"]');
            shapeOptions.forEach(option => {
                option.addEventListener('change', function() {
                    if (this.checked) {
                        selectedShapeType = this.value;
                    }
                });
            });
            
            // 視窗大小改變時重畫
            window.addEventListener('resize', () => {
                resizeCanvas();
                createBackgroundStars();
            });
            resizeCanvas();
            
            // 預載入第一關但不開始遊戲
            loadLevel(0);
            
            console.log("遊戲已初始化，請點擊「開始探索之旅」按鈕開始遊戲");
        }
        
        // 開始遊戲
        function startGame() {
            startScreen.style.display = 'none';
            
            // 根據選擇的形狀類型設置關卡
            setLevelsByShapeType();
            
            // 更新頁面標題
            document.title = `星空探險家 - ${getShapeTypeName()}學習`;
            document.querySelector('h1').textContent = `星空探險家 - ${getShapeTypeName()}星座學習`;
            
            // 更新信息文字
            updateShapeInfoText();
            
            // 重置遊戲狀態
            score = 0;
            streak = 0;
            solvedCount = 0;
            timeLeft = 60;
            isGameActive = true;
            
            // 清空新解鎖的成就列表
            newUnlocks = [];
            
            // 重置成就狀態
            for (const achievement of achievements) {
                achievement.unlocked = false;
            }
            
            // 隨機選擇一個關卡開始
            loadRandomLevel();
            
            // 更新UI
            updateScoreDisplay();
            
            // 重置難度
            currentDifficulty = "普通";
            difficultyDisplay.textContent = `難度: ${currentDifficulty}`;
            
            // 啟動計時器
            startTimer();
            
            // 播放開始音效
            playSound('click');
            
            // 清除現有效果
            clearEffects();
            
            // 重啟動畫循環
            if (!animationFrameId) {
                animate();
            }
            
            console.log("遊戲已開始");
        }
        
        // 設置關卡根據形狀類型
        function setLevelsByShapeType() {
            switch(selectedShapeType) {
                case "triangles":
                    currentLevels = [...triangleLevels];
                    break;
                case "quadrilaterals":
                    currentLevels = [...quadrilateralLevels];
                    break;
                case "all":
                    currentLevels = [...triangleLevels, ...quadrilateralLevels];
                    break;
                default:
                    currentLevels = [...triangleLevels];
            }
            // 確保levels數組引用currentLevels的數據
            levels = currentLevels;
            
            if (debugMode) {
                console.log(`設置關卡類型: ${selectedShapeType}`);
                console.log(`總關卡數: ${levels.length}`);
            }
        }
        
        // 獲取形狀類型名稱
        function getShapeTypeName() {
            switch(selectedShapeType) {
                case "triangles": return "三角形";
                case "quadrilaterals": return "四邊形";
                case "all": return "幾何形狀";
                default: return "幾何形狀";
            }
        }
        
        // 更新形狀信息文字
        function updateShapeInfoText() {
            let infoText = "";
            switch(selectedShapeType) {
                case "triangles":
                    infoText = "連接閃耀的星點，形成指定類型的三角形星座";
                    break;
                case "quadrilaterals":
                    infoText = "連接閃耀的星點，形成指定類型的四邊形星座";
                    break;
                case "all":
                    infoText = "連接閃耀的星點，形成指定類型的幾何星座";
                    break;
                default:
                    infoText = "連接閃耀的星點，形成指定類型的幾何星座";
            }
            shapeInfo.textContent = infoText;
        }
        
        // 重新開始遊戲
        function restartGame() {
            resultScreen.style.display = 'none';
            startGame();
        }
        
        // 顯示視覺提示
        function showVisualHint() {
            if (!isGameActive) return;
            
            playSound('hint');
            
            const level = levels[currentLevelIndex];
            
            // 計算網格尺寸比例
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 根據關卡類型顯示提示
            if (level.type === "triangle") {
                const solutionPoint = level.solutionPoint;
                const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                
                // 繪製閃爍提示效果
                ctx.beginPath();
                ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                
                // 創建漸變
                const gradient = ctx.createRadialGradient(
                    x, y, 0, 
                    x, y, pointRadius * 3 * gridRatio
                );
                gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // 獲取Canvas相對於視窗的位置
                const rect = canvas.getBoundingClientRect();
                
                // 創建閃爍粒子效果
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 30;
                        const px = rect.left + x + Math.cos(angle) * distance;
                        const py = rect.top + y + Math.sin(angle) * distance;
                        createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                    }, i * 100);
                }
            } else if (level.type === "quadrilateral") {
                // 對於四邊形，顯示兩個解點
                for (const solutionPoint of level.solutionPoints) {
                    const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                    const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                    
                    // 繪製閃爍提示效果
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                    
                    // 創建漸變
                    const gradient = ctx.createRadialGradient(
                        x, y, 0, 
                        x, y, pointRadius * 3 * gridRatio
                    );
                    gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                    gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // 獲取Canvas相對於視窗的位置
                    const rect = canvas.getBoundingClientRect();
                    
                    // 創建閃爍粒子效果
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 30;
                            const px = rect.left + x + Math.cos(angle) * distance;
                            const py = rect.top + y + Math.sin(angle) * distance;
                            createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                        }, i * 100);
                    }
                }
            }
            
            // 2秒後消失
            setTimeout(() => drawGame(), 2000);
        }
        
        // 顯示文字提示
        function toggleTextHint() {
            if (hintBox.style.display === 'none') {
                hintBox.style.display = 'block';
                playSound('hint');
                
                // 添加淡入效果
                hintBox.style.opacity = 0;
                setTimeout(() => {
                    hintBox.style.transition = 'opacity 0.5s';
                    hintBox.style.opacity = 1;
                }, 10);
            } else {
                // 添加淡出效果
                hintBox.style.transition = 'opacity 0.5s';
                hintBox.style.opacity = 0;
                
                setTimeout(() => {
                    hintBox.style.display = 'none';
                    hintBox.style.transition = '';
                }, 500);
            }
        }
        
        // 啟動計時器
        function startTimer() {
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                // 閃爍效果當時間少於10秒
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerDisplay.classList.add('pulse-animation');
                    setTimeout(() => timerDisplay.classList.remove('pulse-animation'), 500);
                }
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }
        
        // 更新計時器顯示
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // 時間少於10秒時變紅
            if (timeLeft <= 10) {
                timerDisplay.style.color = '#FF6464';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 100, 100, 0.7)';
            } else {
                timerDisplay.style.color = '#FFD700';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
            }
        }
        
        // 結束遊戲
        function endGame() {
            clearInterval(timerInterval);
            isGameActive = false;
            
            // 檢查並更新最終成就
            checkAchievements();
            
            // 更新成就顯示
            updateAchievementDisplay();
            
            // 顯示結果螢幕
            document.getElementById('finalScore').textContent = `${solvedCount} 個星座`;
            document.getElementById('finalTotalScore').textContent = score;
            resultScreen.style.display = 'flex';
            
            // 創建星點粒子效果
            const numParticles = Math.min(100, solvedCount * 20);
            for (let i = 0; i < numParticles; i++) {
                setTimeout(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight * 0.7;
                    createParticle(x, y, `hsl(${Math.random() * 60 + 180}, 100%, 70%)`);
                }, i * 20);
            }
            
            // 為已解鎖的成就添加特效
            if (newUnlocks.length > 0) {
                setTimeout(() => {
                    const achievementContainers = document.querySelectorAll('.achievement-badge.new-unlock');
                    achievementContainers.forEach((badge, index) => {
                        // 為每個新解鎖的成就創建發光效果
                        setTimeout(() => {
                            // 創建粒子效果
                            const rect = badge.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * 50 + 20;
                                    const x = centerX + Math.cos(angle) * distance;
                                    const y = centerY + Math.sin(angle) * distance;
                                    createParticle(x, y, '#FFD700');
                                }, i * 50);
                            }
                        }, index * 300);
                    });
                }, 500);
            }
            
            console.log("遊戲結束");
        }
        
        // 隨機選擇關卡
        function loadRandomLevel() {
            // 根據連勝調整難度
            let levelPool = levels;
            
            if (streak >= 5) {
                // 從關卡中篩選出困難的
                const hardLevels = levels.filter(l => l.difficulty >= 3);
                if (hardLevels.length > 0) {
                    levelPool = hardLevels;
                    
                    if (currentDifficulty !== "困難") {
                        currentDifficulty = "困難";
                        difficultyDisplay.textContent = `難度: ${currentDifficulty}`;
                    }
                }
            }
            
            // 確保不重複上一個關卡
            let newIndex;
            do {
                if (levelPool.length === 1) {
                    newIndex = 0; // 只有一個關卡時直接選擇
                    break;
                }
                
                if (levelPool !== levels) {
                    // 從困難關卡中選擇
                    const hardIndex = Math.floor(Math.random() * levelPool.length);
                    // 找到在原始關卡陣列中的索引
                    newIndex = levels.findIndex(level => 
                        level.name === levelPool[hardIndex].name && 
                        level.presetLine.from.row === levelPool[hardIndex].presetLine.from.row &&
                        level.presetLine.from.col === levelPool[hardIndex].presetLine.from.col
                    );
                } else {
                    // 從所有關卡中選擇
                    newIndex = Math.floor(Math.random() * levels.length);
                }
            } while (newIndex === currentLevelIndex && levels.length > 1);
            
            currentLevelIndex = newIndex;
            loadLevel(currentLevelIndex);
        }
        
        // 調整Canvas大小
        function resizeCanvas() {
            // 獲取容器大小
            const containerWidth = Math.min(450, window.innerWidth - 40);
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerWidth + 'px';
            
            drawGame();
        }
        
        // 載入關卡
        function loadLevel(index) {
            // 清除所有效果
            clearEffects();
            
            currentLevelIndex = index;
            
            if (!levels[currentLevelIndex]) {
                console.error("關卡載入錯誤：找不到關卡", index);
                if (levels.length > 0) {
                    currentLevelIndex = 0;
                } else {
                    console.error("沒有可用關卡！");
                    return;
                }
            }
            
            const level = levels[currentLevelIndex];
            
            if (debugMode) {
                console.log(`載入關卡: ${level.name} (索引: ${currentLevelIndex})`);
                console.log(`關卡類型: ${level.type}`);
            }
            
            // 更新UI
            document.getElementById('task').textContent = level.description;
            const requiredLines = level.requiredLines || 2; // 默認三角形是2條，四邊形是3條
            document.getElementById('status').textContent = `已連接: 0 條線 (需要連接 ${requiredLines} 條線)`;
            hintBox.style.display = 'none';
            hintBox.textContent = level.hint;
            
            // 隱藏結果訊息
            resultMessage.style.display = 'none';
            
            // 重置遊戲狀態
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            // 繪製遊戲
            drawGame();
            
            // 重啟動畫循環（如果還沒啟動）
            if (!animationFrameId) {
                animate();
            }
        }
        
        // 繪製遊戲
        function drawGame() {
            // 清除畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0B0E2E');
            gradient.addColorStop(1, '#1A1B4B');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製背景星星 - 小點
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // 隨機種子，使星星位置保持一致
            const levelSeed = currentLevelIndex * 10000;
            const pseudoRandom = (seed) => {
                return ((seed * 9301 + 49297) % 233280) / 233280;
            };
            
            // 繪製小型星星
            for (let i = 0; i < 50; i++) {
                const seed = levelSeed + i;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const size = pseudoRandom(seed + 2) * 1.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 繪製星雲效果
            ctx.save();
            for (let i = 0; i < 3; i++) {
                const seed = levelSeed + i * 1000;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const radius = 50 + pseudoRandom(seed + 2) * 100;
                
                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(${50 + i * 20}, ${80 + i * 10}, ${150 + i * 20}, 0.03)`);
                nebulaGradient.addColorStop(0.5, `rgba(${40 + i * 20}, ${60 + i * 10}, ${120 + i * 20}, 0.02)`);
                nebulaGradient.addColorStop(1, 'rgba(20, 30, 80, 0)');
                
                ctx.fillStyle = nebulaGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // 計算網格尺寸比例
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 繪製網格線（淡）
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // 垂直線
            for (let col = 0; col <= numCols; col++) {
                const x = offsetX + col * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + numRows * gridSize * gridRatio);
                ctx.stroke();
            }
            
            // 水平線
            for (let row = 0; row <= numRows; row++) {
                const y = offsetY + row * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + numCols * gridSize * gridRatio, y);
                ctx.stroke();
            }
            
            // 預設線
            if (!levels[currentLevelIndex]) return; // 避免初始化問題
            
            const level = levels[currentLevelIndex];
            const presetLine = level.presetLine;
            
            // 轉換預設線的座標
            const fromX = offsetX + presetLine.from.col * gridSize * gridRatio;
            const fromY = offsetY + presetLine.from.row * gridSize * gridRatio;
            const toX = offsetX + presetLine.to.col * gridSize * gridRatio;
            const toY = offsetY + presetLine.to.row * gridSize * gridRatio;
            
            // 繪製預設線
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            
            // 使用漸變
            const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            lineGradient.addColorStop(0, '#8A9EFF');
            lineGradient.addColorStop(0.5, '#ADC2FF');
            lineGradient.addColorStop(1, '#8A9EFF');
            
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // 添加發光效果
            ctx.shadowColor = 'rgba(138, 158, 255, 0.5)';
            ctx.shadowBlur = 10;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // 移除陰影以防影響其他繪製
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // 繪製用戶連接的線條
            for (const line of userLines) {
                const fromX = offsetX + line.from.col * gridSize * gridRatio;
                const fromY = offsetY + line.from.row * gridSize * gridRatio;
                const toX = offsetX + line.to.col * gridSize * gridRatio;
                const toY = offsetY + line.to.row * gridSize * gridRatio;
                
                // 計算線的漸變
                const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
                lineGradient.addColorStop(0, '#64FFDA');
                lineGradient.addColorStop(0.5, '#A0FFE6');
                lineGradient.addColorStop(1, '#64FFDA');
                
                // 發光效果
                ctx.shadowColor = 'rgba(100, 255, 218, 0.5)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 移除陰影
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
            
            // 繪製當前拖動的線
            if (selectedPoint !== null) {
                const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                
                // 漸變顏色的虛線
                const dashLineGradient = ctx.createLinearGradient(fromX, fromY, lastMouseX, lastMouseY);
                dashLineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                dashLineGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(lastMouseX, lastMouseY);
                ctx.strokeStyle = dashLineGradient;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // 虛線效果
                ctx.stroke();
                ctx.setLineDash([]); // 重置為實線
            }
            
            // 創建星星映射，避免重複創建
            const starMap = new Map();
            
            // 清除現有的DOM星星
            clearEffects();
            
            // 初始化星星陣列
            stars = [];
            
            // 繪製所有網格點
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const x = offsetX + col * gridSize * gridRatio;
                    const y = offsetY + row * gridSize * gridRatio;
                    
                    // 確定點的顏色和大小（預設線端點、用戶線端點、普通點）
                    let isSpecialPoint = false;
                    
                    // 檢查是否為預設線端點
                    if ((row === presetLine.from.row && col === presetLine.from.col) ||
                        (row === presetLine.to.row && col === presetLine.to.col)) {
                        isSpecialPoint = true;
                    }
                    
                    // 檢查是否為用戶線端點
                    for (const line of userLines) {
                        if ((row === line.from.row && col === line.from.col) ||
                            (row === line.to.row && col === line.to.col)) {
                            isSpecialPoint = true;
                            break;
                        }
                    }
                    
                    // 檢查是否為選中或懸停的點
                    const isSelected = selectedPoint && row === selectedPoint.row && col === selectedPoint.col;
                    const isHovered = hoveredPoint && row === hoveredPoint.row && col === hoveredPoint.col;
                    
                    // 決定點的繪製方式
                    if (isSpecialPoint || isSelected || isHovered) {
                        // 星點閃爍效果
                        const pulseSize = (Math.sin(Date.now() / 300) * 0.2 + 1);
                        
                        // 發光效果
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 2 * gridRatio * pulseSize, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(
                            x, y, 0,
                            x, y, pointRadius * 2 * gridRatio * pulseSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // 主星點
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        
                        // 添加星光效果
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.8 * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fill();
                        
                        // 獲取Canvas相對於視窗的位置
                        const rect = canvas.getBoundingClientRect();
                        
                        // 在DOM中創建星光效果
                        if (!starMap.has(`${row},${col}`)) {
                            const star = createStar(
                                rect.left + x, 
                                rect.top + y, 
                                pointRadius * 1.5 * gridRatio
                            );
                            stars.push(star);
                            starMap.set(`${row},${col}`, star);
                        }
                    } else {
                        // 普通點
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.7 * gridRatio, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fill();
                    }
                    
                    // 選中或懸停的點高亮
                    if (isSelected || isHovered) {
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 1.2 * gridRatio, 0, Math.PI * 2);
                        ctx.strokeStyle = isSelected ? '#ffffff' : 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            // 更新狀態
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `已連接: ${userLines.length} 條線 (需要連接 ${requiredLines} 條線)`;
        }
        
        // 查找點擊位置的網格點
        function findGridPoint(x, y) {
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const pointX = offsetX + col * gridSize * gridRatio;
                    const pointY = offsetY + row * gridSize * gridRatio;
                    
                    const distance = Math.sqrt(
                        Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2)
                    );
                    
                    if (distance <= pointRadius * 2 * gridRatio) {
                        return { row, col };
                    }
                }
            }
            
            return null;
        }
        
        // 檢查是否可以連接兩個點
        function canConnectPoints(fromPoint, toPoint) {
            // 檢查是否已經連接
            for (const line of userLines) {
                if ((line.from.row === fromPoint.row && line.from.col === fromPoint.col &&
                     line.to.row === toPoint.row && line.to.col === toPoint.col) ||
                    (line.from.row === toPoint.row && line.from.col === toPoint.col &&
                     line.to.row === fromPoint.row && line.to.col === fromPoint.col)) {
                    return false;
                }
            }
            
            // 檢查是否與預設線重複
            const presetLine = levels[currentLevelIndex].presetLine;
            if ((fromPoint.row === presetLine.from.row && fromPoint.col === presetLine.from.col &&
                 toPoint.row === presetLine.to.row && toPoint.col === presetLine.to.col) ||
                (fromPoint.row === presetLine.to.row && fromPoint.col === presetLine.to.col &&
                 toPoint.row === presetLine.from.row && toPoint.col === presetLine.from.col)) {
                return false;
            }
            
            return true;
        }
        
        // 更新分數顯示
        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = `分數: ${score}`;
            document.getElementById('streakDisplay').textContent = `連勝: ${streak}`;
            document.getElementById('solvedDisplay').textContent = `已解題: ${solvedCount}`;
        }
        
        // 加分
        function addPoints(points) {
            const scoreDisplay = document.getElementById('scoreDisplay');
            
            // 記錄原始分數
            const oldScore = score;
            
            // 增加分數
            score += points;
            
            // 更新分數顯示
            updateScoreDisplay();
            
            // 添加視覺效果
            scoreDisplay.classList.add('pulse-animation');
            setTimeout(() => {
                scoreDisplay.classList.remove('pulse-animation');
            }, 500);
            
            return score - oldScore; // 返回增加的分數
        }
        
        // 檢查形狀
        function checkShape() {
            if (!isGameActive) return;
            
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2; // 預設為三角形(2條線)
            
            // 檢查已連接的線條數量
            if (userLines.length !== requiredLines) {
                showResultMessage(`你需要連接恰好${requiredLines}條線來完成${level.name}星座！`, false);
                playSound('wrong');
                return;
            }
            
            const result = level.checkFunction();
            
            if (result) {
                handleCorrectShape(level);
            } else {
                // 失敗 - 重置連勝
                streak = 0;
                updateScoreDisplay();
                
                // 播放錯誤音效
                playSound('wrong');
                
                // 顯示失敗消息
                showResultMessage("還不是正確的" + level.name + "星座！請再試一次。", false);
            }
        }
        
        // 處理正確的形狀
        function handleCorrectShape(level) {
            // 完成！
            isComplete = true;
            
            // 播放正確音效
            playSound('correct');
            
            // 增加連勝
            streak++;
            
            // 增加已解題數
            solvedCount++;
            
            // 計算分數 - 基於難度和連勝
            const basePoints = level.difficulty * 10;
            const streakBonus = streak > 1 ? streak * 5 : 0;
            const totalPoints = basePoints + streakBonus;
            
            // 加分
            const pointsAdded = addPoints(totalPoints);
            
            // 更新狀態和顯示
            const statusText = `${level.congratsMessage} +${pointsAdded}分`;
            showResultMessage(statusText, true);
            
            // 檢查是否解鎖新成就
            checkAchievements();
            
            // 創建星點連接特效
            createConnectionEffects();
            
            // 漸變光芒效果
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 創建完成粒子效果
            const centerX = rect.left + canvas.width / 2;
            const centerY = rect.top + canvas.height / 2;
            
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * canvas.width * 0.5;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    createParticle(x, y, `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, 255, 0.8)`);
                }, i * 50);
            }
            
            // 1.5秒後自動進入下一題
            setTimeout(() => {
                if (isGameActive) {
                    loadRandomLevel();
                }
            }, 1500);
        }
        
        // 檢查是否解鎖成就
        function checkAchievements() {
            // 檢查每個成就的解鎖條件
            for (let i = 0; i < achievements.length; i++) {
                const achievement = achievements[i];
                
                if (!achievement.unlocked && solvedCount >= achievement.level) {
                    // 解鎖成就
                    achievement.unlocked = true;
                    
                    // 添加到新解鎖列表
                    newUnlocks.push(achievement);
                    
                    // 顯示通知
                    setTimeout(() => {
                        showAchievementPopup(achievement);
                    }, 500 + i * 1000); // 如果連續解鎖多個成就，分開時間顯示
                }
            }
        }
        
        // 顯示成就解鎖彈窗
        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            const iconEl = popup.querySelector('.achievement-icon-large');
            const titleEl = popup.querySelector('.achievement-popup-title');
            const descEl = popup.querySelector('.achievement-popup-desc');
            
            // 設置內容
            iconEl.textContent = achievement.icon;
            titleEl.textContent = `解鎖成就：${achievement.name}`;
            descEl.textContent = achievement.description;
            
            // 顯示彈窗
            popup.classList.add('show');
            
            // 播放解鎖成就音效
            playAchievementSound();
            
            // 2秒後隱藏 (縮短顯示時間)
            setTimeout(() => {
                popup.classList.remove('show');
            }, 2000);
        }
        
        // 播放成就解鎖音效
        function playAchievementSound() {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // 特殊的成就解鎖音效 - 华丽的上升音
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.type = 'sine';
                oscillator2.type = 'triangle';
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // 第一個音調軌跡
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                oscillator1.frequency.linearRampToValueAtTime(1046.50, audioContext.currentTime + 0.4); // C6
                
                // 第二個音調軌跡 (稍微延遲，添加和聲效果)
                oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator2.frequency.linearRampToValueAtTime(987.77, audioContext.currentTime + 0.25); // B5
                oscillator2.frequency.linearRampToValueAtTime(1318.51, audioContext.currentTime + 0.45); // E6
                
                // 漸變音量
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator1.start();
                oscillator2.start();
                oscillator1.stop(audioContext.currentTime + 0.8);
                oscillator2.stop(audioContext.currentTime + 0.8);
            } catch(e) {
                console.warn('Error playing achievement sound:', e);
            }
        }
        
        // 更新成就顯示
        function updateAchievementDisplay() {
            const container = document.getElementById('achievementsContainer');
            container.innerHTML = '';
            
            // 先添加所有解鎖的成就
            for (const achievement of achievements) {
                const badge = document.createElement('div');
                badge.className = 'achievement-badge' + (achievement.unlocked ? ' unlocked' : ' locked');
                
                // 檢查是否為本次遊戲新解鎖
                if (newUnlocks.includes(achievement)) {
                    badge.classList.add('new-unlock');
                }
                
                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = achievement.icon;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                tooltip.textContent = achievement.unlocked 
                    ? `${achievement.name}: ${achievement.description}` 
                    : `????: 完成${achievement.level}個星座解鎖`;
                
                badge.appendChild(icon);
                badge.appendChild(tooltip);
                container.appendChild(badge);
            }
        }
        
        // 創建連接特效
        function createConnectionEffects() {
            // 獲取Canvas位置
            const rect = canvas.getBoundingClientRect();
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 預設線的兩個端點
            const presetLine = levels[currentLevelIndex].presetLine;
            const p1 = {
                x: rect.left + offsetX + presetLine.from.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.from.row * gridSize * gridRatio
            };
            const p2 = {
                x: rect.left + offsetX + presetLine.to.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.to.row * gridSize * gridRatio
            };
            
            // 創建預設線的連接效果
            createConstellationLine(p1.x, p1.y, p2.x, p2.y);
            
            // 創建用戶線的連接效果
            for (const line of userLines) {
                const fromX = rect.left + offsetX + line.from.col * gridSize * gridRatio;
                const fromY = rect.top + offsetY + line.from.row * gridSize * gridRatio;
                const toX = rect.left + offsetX + line.to.col * gridSize * gridRatio;
                const toY = rect.top + offsetY + line.to.row * gridSize * gridRatio;
                
                createConstellationLine(fromX, fromY, toX, toY);
            }
        }
        
        // 顯示結果消息
        function showResultMessage(message, isSuccess) {
            resultMessage.textContent = message;
            resultMessage.style.display = 'block';
            
            // 設置樣式
            resultMessage.className = isSuccess ? 
                'result-message result-success' : 
                'result-message result-fail';
                
            // 效果
            resultMessage.classList.add('pulse-animation');
            setTimeout(() => {
                resultMessage.classList.remove('pulse-animation');
            }, 500);
            
            // 添加淡入效果
            resultMessage.style.opacity = 0;
            setTimeout(() => {
                resultMessage.style.transition = 'opacity 0.3s';
                resultMessage.style.opacity = 1;
            }, 10);
        }
        
        // 重置線條
        function resetLines() {
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `已連接: 0 條線 (需要連接 ${requiredLines} 條線)`;
            
            // 隱藏結果訊息
            resultMessage.style.display = 'none';
            
            // 播放點擊音效
            playSound('click');
            
            // 清除效果
            clearEffects();
            
            drawGame();
        }
        
        // 獲取點集合（包括預設線端點和用戶連線端點）
        function getShapePoints() {
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2;
            
            if (userLines.length !== requiredLines) return null;
            
            const presetLine = level.presetLine;
            const points = new Set();
            
            // 添加預設線的兩個端點
            points.add(JSON.stringify(presetLine.from));
            points.add(JSON.stringify(presetLine.to));
            
            // 添加用戶連線的所有點
            for (const line of userLines) {
                points.add(JSON.stringify(line.from));
                points.add(JSON.stringify(line.to));
            }
            
            // 轉換回對象格式
            const shapePoints = Array.from(points).map(p => JSON.parse(p));
            
            // 三角形需要3個點，四邊形需要4個點
            const expectedPointCount = level.type === "triangle" ? 3 : 4;
            
            if (shapePoints.length !== expectedPointCount) {
                if (debugMode) {
                    console.warn(`點數量不符: 期望${expectedPointCount}個點, 實際${shapePoints.length}個點`);
                }
                return null;
            }
            
            return shapePoints;
        }
        
        // 獲取三角形的三個點
        function getTrianglePoints() {
            if (userLines.length !== 2) return null;
            
            const presetLine = levels[currentLevelIndex].presetLine;
            const presetPoints = [presetLine.from, presetLine.to];
            
            // 找出第三個點（不在預設線上的點）
            let thirdPoint = null;
            
            for (const line of userLines) {
                if (!isPointInArray(line.from, presetPoints)) {
                    thirdPoint = line.from;
                    break;
                }
                if (!isPointInArray(line.to, presetPoints)) {
                    thirdPoint = line.to;
                    break;
                }
            }
            
            if (!thirdPoint) return null;
            
            return {
                p1: presetLine.from,
                p2: presetLine.to,
                p3: thirdPoint
            };
        }
        
        // 獲取四邊形的四個點（按照順時針或逆時針順序）
        function getQuadrilateralPoints() {
            const points = getShapePoints();
            if (!points || points.length !== 4) return null;
            
            // 找出中心點
            const centerX = points.reduce((sum, p) => sum + p.col, 0) / 4;
            const centerY = points.reduce((sum, p) => sum + p.row, 0) / 4;
            
            // 按照角度排序（順時針或逆時針都可以）
            points.sort((a, b) => {
                const angleA = Math.atan2(a.row - centerY, a.col - centerX);
                const angleB = Math.atan2(b.row - centerY, b.col - centerX);
                return angleA - angleB;
            });
            
            if (debugMode) {
                console.log("排序後的四邊形頂點:", 
                    points.map(p => `(${p.row},${p.col})`).join(' -> '));
            }
            
            // 返回排序後的四個點
            return {
                p1: points[0],
                p2: points[1],
                p3: points[2],
                p4: points[3]
            };
        }
        
        // 檢查點是否在數組中
        function isPointInArray(point, pointArray) {
            return pointArray.some(p => p.row === point.row && p.col === point.col);
        }
        
        // 計算兩點之間的距離
        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow((p1.col - p2.col), 2) + 
                Math.pow((p1.row - p2.row), 2)
            );
        }
        
        // 計算斜率
        function calculateSlope(p1, p2) {
            // 避免除以零的情況
            if (p1.col === p2.col) return Infinity;
            return (p1.row - p2.row) / (p1.col - p2.col);
        }
        
        // 計算向量
        function calculateVector(p1, p2) {
            return {
                x: p2.col - p1.col,
                y: p2.row - p1.row
            };
        }
        
        // 計算向量的點積
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        // 計算向量的模（長度）
        function vectorMagnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        // 計算兩個向量之間的角度（弧度）
        function calculateAngle(v1, v2) {
            const dot = dotProduct(v1, v2);
            const mag1 = vectorMagnitude(v1);
            const mag2 = vectorMagnitude(v2);
            
            // 防止除以零或計算誤差
            if (mag1 === 0 || mag2 === 0) return 0;
            
            // 確保值在-1到1之間以避免因計算誤差導致的acos錯誤
            const cosTheta = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
            return Math.acos(cosTheta);
        }
        
        // 檢查兩條線是否平行
        function areLinesParallel(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // 平行向量的叉積為零
            const crossProduct = v1.x * v2.y - v1.y * v2.x;
            
            // 考慮浮點數誤差，使用較寬鬆的標準
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(crossProduct) < tolerance;
        }
        
        // 檢查兩條線是否垂直
        function areLinesOrthogonal(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // 垂直向量的點積為零
            const dot = dotProduct(v1, v2);
            
            // 考慮浮點數誤差
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(dot) < tolerance;
        }
        
        // 檢查是否為等腰三角形
        function isIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 使用較嚴格的容差
            const tolerance = 0.08; // 更嚴格的容差來判斷相等
            const notEqualTolerance = 0.15; // 判斷不相等的容差
            
            // 使用比率而不是絕對差值來處理較大的三角形
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`等腰檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`相等閾值: ${tolerance}, 不相等閾值: ${notEqualTolerance}`);
            }
            
            // 等腰三角形必須恰好有兩條邊相等，第三條邊不等於其他兩條
            const sides12Equal = ratio12 < tolerance;
            const sides23Equal = ratio23 < tolerance;
            const sides31Equal = ratio31 < tolerance;
            
            // 檢查是否為等邊三角形（三條邊都相等）
            const isEquilateral = sides12Equal && sides23Equal && sides31Equal;
            
            // 返回true只有在恰好兩條邊相等並且不是等邊三角形的情況
            return !isEquilateral && (
                (sides12Equal && !sides23Equal && !sides31Equal) ||
                (!sides12Equal && sides23Equal && !sides31Equal) ||
                (!sides12Equal && !sides23Equal && sides31Equal)
            );
        }
        
        // 檢查是否為等邊三角形
        function isEquilateralTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 使用更寬鬆的容差，讓更多視覺上正確的三角形能被接受
            const tolerance = 0.15; // 增加容差到15%
            
            // 使用多種檢測方法結合判斷
            
            // 方法1: 邊長比率檢測
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            // 計算最大偏差
            const maxRatio = Math.max(ratio12, ratio23, ratio31);
            const edgeRatioCheck = maxRatio < tolerance;
            
            // 方法2: 角度檢測 (60度角檢測)
            // 計算三個向量
            const v1 = calculateVector(points.p1, points.p2);
            const v2 = calculateVector(points.p2, points.p3);
            const v3 = calculateVector(points.p3, points.p1);
            
            // 計算夾角 (理想情況是60度，即π/3弧度)
            const angle1 = calculateAngle({x: -v3.x, y: -v3.y}, v1);
            const angle2 = calculateAngle({x: -v1.x, y: -v1.y}, v2);
            const angle3 = calculateAngle({x: -v2.x, y: -v2.y}, v3);
            
            // 檢查角度是否接近60度(π/3)
            const angleTolerance = 0.15; // 角度容差
            const angleCheck = (
                Math.abs(angle1 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle2 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle3 - Math.PI/3) < angleTolerance * Math.PI/3
            );
            
            // 方法3: 使用預設解法檢測 (比較與解答點的近似度)
            let solutionCheck = false;
            const level = levels[currentLevelIndex];
            if (level.solutionPoint) {
                // 檢查第三點是否接近預設的解答點
                const solutionDist = calculateDistance(points.p3, level.solutionPoint);
                solutionCheck = solutionDist < 1.5; // 如果點在解答附近，也認為正確
            }
            
            if (debugMode) {
                console.log(`等邊檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`邊長比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`最大偏差: ${maxRatio.toFixed(4)}, 閾值: ${tolerance}`);
                console.log(`角度檢測: ${angleCheck}, 解答檢測: ${solutionCheck}`);
            }
            
            // 放寬標準：只要滿足邊長比例或角度檢測的任一項，就認為是等邊三角形
            return edgeRatioCheck || angleCheck || solutionCheck;
        }
        
        // 檢查是否為直角三角形
        function isRightTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三邊長平方
            const sides = [
                {
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // 檢查畢氏定理 a² + b² = c²
            const tolerance = 0.15; // 使用較寬鬆的容差
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            // 使用向量方法驗證
            const v1 = calculateVector(sides[0].points[0], sides[0].points[1]);
            const v2 = calculateVector(sides[1].points[0], sides[1].points[1]);
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            
            // 正交向量的點積應接近於零
            const orthogonalCheck = Math.abs(dotProduct) / (vectorMagnitude(v1) * vectorMagnitude(v2)) < 0.15;
            
            if (debugMode) {
                console.log(`直角檢測: 畢氏比率 ${pythagoreanRatio.toFixed(4)}`);
                console.log(`正交檢查: ${orthogonalCheck}`);
            }
            
            return Math.abs(pythagoreanRatio - 1) < tolerance || orthogonalCheck;
        }
        
        // 檢查是否為直角等腰三角形
        function isRightIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度和平方
            const sides = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    length: calculateDistance(points.p3, points.p1),
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // 兩條短邊的比例
            const tolerance = 0.15; // 使用較寬鬆的容差
            const isoscelesRatio = Math.abs(sides[0].length - sides[1].length) / Math.max(sides[0].length, sides[1].length);
            
            // 畢氏定理檢查
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            if (debugMode) {
                console.log(`直角等腰檢測: 等腰比率 ${isoscelesRatio.toFixed(4)}, 畢氏比率 ${pythagoreanRatio.toFixed(4)}`);
            }
            
            return isoscelesRatio < tolerance && Math.abs(pythagoreanRatio - 1) < tolerance;
        }
        
        // 檢查是否為不等邊三角形
        function isScaleneTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 檢查所有邊的比例不相等
            const tolerance = 0.15; // 使用較寬鬆的容差
            
            // 使用比率檢查
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`不等邊檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
            }
            
            // 所有邊都不相等，也就是沒有兩條邊相等
            return ratio12 > tolerance && ratio23 > tolerance && ratio31 > tolerance;
        }
        
        // 檢查是否為正方形
        function isSquare() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 計算對角線
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // 檢查所有邊是否嚴格相等 - 使用更嚴格的容差
            const tolerance = 0.06; // 更嚴格的容差，一般長方形不會通過此檢查
            const avgLength = edges.reduce((sum, edge) => sum + edge.length, 0) / 4;
            
            // 檢查每條邊與平均值的偏差
            const edgeDeviations = edges.map(edge => 
                Math.abs(edge.length - avgLength) / avgLength
            );
            
            const maxDeviation = Math.max(...edgeDeviations);
            const allSidesEqual = maxDeviation < tolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 最大邊長偏差率: ${maxDeviation.toFixed(4)}, 閾值: ${tolerance}`);
                console.log(`正方形檢測 - 四邊長度: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // 檢查對角線是否近似相等
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 對角線比率: ${diagRatio.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 檢查相鄰邊是否嚴格垂直
            const anglesTolerance = 0.08; // 更嚴格的角度容差
            const rightAngles = [
                Math.abs(Math.PI/2 - calculateAngle(edges[0].vector, edges[1].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[1].vector, edges[2].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[2].vector, edges[3].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[3].vector, edges[0].vector))
            ];
            
            const maxAngleDeviation = Math.max(...rightAngles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 最大角度偏差: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}度, 閾值: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}度`);
            }
            
            // 這三個條件必須同時滿足
            return allSidesEqual && diagEqual && hasRightAngles;
        }
        
        // 檢查是否為長方形
        function isRectangle() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 對邊應該相等，但相鄰邊可能不等
            const tolerance = 0.1; // 對邊相等的容差
            
            // 檢查對邊是否相等（第1、3邊相等，第2、4邊相等）
            const ratio13 = Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length);
            const ratio24 = Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length);
            
            const oppositeSidesEqual = ratio13 < tolerance && ratio24 < tolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 對邊比率: ${ratio13.toFixed(4)}, ${ratio24.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 計算對角線
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // 檢查對角線是否相等
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 對角線比率: ${diagRatio.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 檢查是否有直角
            const anglesTolerance = 0.08; // 更嚴格的角度容差
            const angles = [
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[0].vector.x, y: -edges[0].vector.y}, 
                    edges[3].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[1].vector.x, y: -edges[1].vector.y}, 
                    edges[0].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[2].vector.x, y: -edges[2].vector.y}, 
                    edges[1].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[3].vector.x, y: -edges[3].vector.y}, 
                    edges[2].vector
                ))
            ];
            
            const maxAngleDeviation = Math.max(...angles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 最大角度偏差: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}度, 閾值: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}度`);
            }
            
            // 額外檢查：確保不是正方形
            // 檢查相鄰邊是否不等（至少有一組相鄰邊差異較大）
            const adjacentRatio12 = Math.abs(edges[0].length - edges[1].length) / Math.max(edges[0].length, edges[1].length);
            const adjacentRatio23 = Math.abs(edges[1].length - edges[2].length) / Math.max(edges[1].length, edges[2].length);
            const adjacentRatio34 = Math.abs(edges[2].length - edges[3].length) / Math.max(edges[2].length, edges[3].length);
            const adjacentRatio41 = Math.abs(edges[3].length - edges[0].length) / Math.max(edges[3].length, edges[0].length);
            
            // 至少有一組相鄰邊差異較大（不是正方形）
            const squareTolerance = 0.06; // 與正方形判斷一致
            const notSquare = adjacentRatio12 > squareTolerance || 
                              adjacentRatio23 > squareTolerance ||
                              adjacentRatio34 > squareTolerance ||
                              adjacentRatio41 > squareTolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 非正方形檢查: ${notSquare}, 相鄰邊比率: ${adjacentRatio12.toFixed(4)}, ${adjacentRatio23.toFixed(4)}, ${adjacentRatio34.toFixed(4)}, ${adjacentRatio41.toFixed(4)}`);
            }
            
            // 長方形條件：對邊相等、對角線相等、有直角，但不是正方形
            return oppositeSidesEqual && diagEqual && hasRightAngles && notSquare;
        }
        
        // 檢查是否為平行四邊形
        function isParallelogram() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 檢查對邊是否平行和相等
            const tolerance = 0.15; // 使用較寬鬆的容差
            
            // 檢查對邊是否相等
            const oppositeSidesEqual = 
                Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length) < tolerance &&
                Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length) < tolerance;
            
            // 檢查對邊是否平行
            const parallelCheck1 = areLinesParallel(
                points.p1, points.p2,
                points.p3, points.p4
            );
            
            const parallelCheck2 = areLinesParallel(
                points.p2, points.p3,
                points.p4, points.p1
            );
            
            if (debugMode) {
                console.log(`平行四邊形檢測: 對邊相等 ${oppositeSidesEqual}, 平行檢查1 ${parallelCheck1}, 平行檢查2 ${parallelCheck2}`);
                console.log(`邊長: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // 檢查是否是長方形或正方形
            const isRect = isRectangle();
            const isSq = isSquare();
            
            // 是平行四邊形但不是長方形或正方形
            return oppositeSidesEqual && parallelCheck1 && parallelCheck2 && !isRect && !isSq;
        }
        
        // 滑鼠事件處理
        function handleMouseMove(e) {
            if (!isGameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 更新懸停點
            const previousHovered = hoveredPoint;
            hoveredPoint = findGridPoint(x, y);
            
            // 如果懸停點發生變化，添加星星閃爍動畫
            if (hoveredPoint && (!previousHovered || 
                previousHovered.row !== hoveredPoint.row || 
                previousHovered.col !== hoveredPoint.col)) {
                playSound('click');
                
                // 當懸停到新點時，可以添加粒子效果
                const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                const pointX = offsetX + hoveredPoint.col * gridSize * gridRatio;
                const pointY = offsetY + hoveredPoint.row * gridSize * gridRatio;
                
                // 添加微弱的粒子效果
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 15;
                        createParticle(
                            rect.left + pointX + Math.cos(angle) * distance, 
                            rect.top + pointY + Math.sin(angle) * distance
                        );
                    }, i * 50);
                }
            }
            
            // 更新拖動線的終點
            if (selectedPoint !== null) {
                lastMouseX = x;
                lastMouseY = y;
            }
            
            // 更新工具提示
            updateTooltip(e);
            
            drawGame();
        }
        
        function updateTooltip(e) {
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                
                if (selectedPoint === null) {
                    tooltip.textContent = '點擊此星點開始連線';
                } else if (hoveredPoint.row === selectedPoint.row && hoveredPoint.col === selectedPoint.col) {
                    tooltip.textContent = '取消選擇此星點';
                } else if (canConnectPoints(selectedPoint, hoveredPoint)) {
                    tooltip.textContent = '連接到此星點';
                } else {
                    tooltip.textContent = '已經連接過這兩點';
                }
                
                // 漸變出現效果
                tooltip.style.opacity = 0;
                tooltip.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    tooltip.style.opacity = 1;
                }, 10);
            } else {
                tooltip.style.opacity = 0;
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 300);
            }
        }
        
        function handleMouseDown(e) {
            if (!isGameActive || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // 取消選擇
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // 選擇第一個點
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // 獲取Canvas相對於視窗的位置和座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // 選擇點時的粒子效果
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // 連接到第二個點
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // 獲取點座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    const toX = offsetX + gridPoint.col * gridSize * gridRatio;
                    const toY = offsetY + gridPoint.row * gridSize * gridRatio;
                    
                    // 創建連接效果
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // 獲取當前關卡所需的線條數
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // 自動檢測 - 如果完成所需線條數
                    if (userLines.length === requiredLines) {
                        // 短暫延遲讓用戶看到完成的形狀
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleMouseUp(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // 連接到第二個點
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // 創建連接效果
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // 獲取當前關卡所需的線條數
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // 自動檢測 - 如果完成所需線條數
                if (userLines.length === requiredLines) {
                    // 短暫延遲讓用戶看到完成的形狀
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // 觸控事件處理
        function handleTouchStart(e) {
            if (!isGameActive || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // 取消選擇
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // 選擇第一個點
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // 獲取Canvas相對於視窗的位置和座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // 選擇點時的粒子效果
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // 連接到第二個點
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // 創建連接效果
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // 獲取當前關卡所需的線條數
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // 自動檢測 - 如果完成所需線條數
                    if (userLines.length === requiredLines) {
                        // 短暫延遲讓用戶看到完成的形狀
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleTouchMove(e) {
            if (!isGameActive || selectedPoint === null || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastMouseX = touch.clientX - rect.left;
            lastMouseY = touch.clientY - rect.top;
            
            // 更新懸停點
            hoveredPoint = findGridPoint(lastMouseX, lastMouseY);
            
            drawGame();
        }
        
        function handleTouchEnd(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = lastMouseX;
                y = lastMouseY;
            }
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // 連接到第二個點
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // 創建連接效果
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // 獲取當前關卡所需的線條數
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // 自動檢測 - 如果完成所需線條數
                if (userLines.length === requiredLines) {
                    // 短暫延遲讓用戶看到完成的形狀
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // 在控制台啟用debug模式的方法
        window.enableDebug = function() {
            debugMode = true;
            console.log("調試模式已啟用");
        };
        
        window.disableDebug = function() {
            debugMode = false;
            console.log("調試模式已禁用");
        };
        
        // 初始化遊戲
        window.onload = init;
    </script>
    <!-- MindCrafter 署名 -->
    <div style="text-align: center; margin-top: 15px; margin-bottom: 10px; font-size: 14px; opacity: 0.7;">
        <span style="color: #64FFDA;">@ MindCrafter</span>
    </div>
    
    <!-- PWA 安裝按鈕 -->
    <div id="installContainer" style="display: none; position: fixed; bottom: 20px; left: 20px; z-index: 900;">
        <button id="installBtn" style="background: linear-gradient(135deg, #64FFDA, #00D0B6); color: #0A0B2F; padding: 10px 15px; border: none; border-radius: 30px; font-weight: bold; box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4); display: flex; align-items: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" style="margin-right: 8px; fill: #0A0B2F;">
                <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
            </svg>
            安裝應用
        </button>
    </div>

    <!-- PWA manifest -->
    <script id="manifest" type="application/manifest+json">
    {
      "name": "星空探險家",
      "short_name": "星空探險",
      "description": "互動式幾何學習遊戲，連接星點形成各種幾何形狀星座",
      "start_url": "./",
      "display": "standalone",
      "background_color": "#0A0B2F",
      "theme_color": "#0A0B2F",
      "orientation": "portrait",
      "icons": [
        {
          "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNCI+PHJlY3Qgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIgZmlsbD0iIzBBMEIyRiIvPjxwYXRoIGQ9Ik03NjggNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek0yNTYgNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek01MTIgNDQ4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2eiIgZmlsbD0iI0ZGRDcwMCIvPjxwYXRoIGQ9Ik03NjggNTc2YzE4IDAgMzYgMiA1MyA2TDUxMiAyODhjLTEzIDI1LTM0IDQ2LTU5IDU5bDMwOSAyMzVjMS0yIDMtNCA1LTZtMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PHBhdGggZD0iTTQ1OSA0NDhsLTIwMyAyMjRjMjUgMTMgNDYgMzQgNTkgNTlsMjA0LTIyNGMtMjYtMTMtNDgtMzUtNjAtNTltMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PC9zdmc+",
          "sizes": "512x512",
          "type": "image/svg+xml"
        }
      ]
    }
    </script>

    <!-- Service worker 註冊 -->
    <script>
        // 檢查是否支援 Service Worker API
        if ('serviceWorker' in navigator) {
            // 在頁面載入完成後註冊 service worker
            window.addEventListener('load', function() {
                // 創建 blob URL 用於 service worker
                const swScript = `
                    const CACHE_NAME = 'star-explorer-v1';
                    const urlsToCache = [
                        './',
                        './index.html'
                    ];

                    // 安裝 service worker 時快取必要資源
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    console.log('Cache opened');
                                    return cache.addAll(urlsToCache);
                                })
                        );
                    });

                    // 攔截網路請求
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => {
                                    // 如果快取中有對應的資源，則直接返回
                                    if (response) {
                                        return response;
                                    }
                                    
                                    // 複製請求，以便在後續使用
                                    const fetchRequest = event.request.clone();
                                    
                                    // 嘗試從網路獲取資源
                                    return fetch(fetchRequest)
                                        .then(response => {
                                            if (!response || response.status !== 200 || response.type !== 'basic') {
                                                return response;
                                            }
                                            
                                            // 複製響應
                                            const responseToCache = response.clone();
                                            
                                            // 將響應添加到快取
                                            caches.open(CACHE_NAME)
                                                .then(cache => {
                                                    cache.put(event.request, responseToCache);
                                                });
                                                
                                            return response;
                                        });
                                })
                                .catch(() => {
                                    // 如果無法獲取資源並且也不在快取中，返回離線頁面或其他回退內容
                                    return new Response('No internet connection. Please try again later.');
                                })
                        );
                    });

                    // 當新的 service worker 取得控制權時，刷新快取
                    self.addEventListener('activate', event => {
                        const cacheWhitelist = [CACHE_NAME];
                        
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheWhitelist.indexOf(cacheName) === -1) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                    });
                `;
                
                const blob = new Blob([swScript], {type: 'application/javascript'});
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // 處理 PWA 安裝功能
        let deferredPrompt;
        const installContainer = document.getElementById('installContainer');
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            // 阻止 Chrome 默認的安裝提示
            e.preventDefault();
            // 保存事件以便稍後調用
            deferredPrompt = e;
            // 顯示自定義安裝按鈕
            installContainer.style.display = 'block';
        });

        installBtn.addEventListener('click', (e) => {
            // 隱藏安裝按鈕
            installContainer.style.display = 'none';
            // 顯示安裝提示
            deferredPrompt.prompt();
            // 等待用戶回應
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('用戶接受了安裝應用');
                } else {
                    console.log('用戶拒絕了安裝應用');
                }
                deferredPrompt = null;
            });
        });

        window.addEventListener('appinstalled', (evt) => {
            // 記錄應用安裝成功
            console.log('應用安裝成功');
        });

        // 從 URL 中創建內聯 Manifest
        const manifestLinkEl = document.querySelector('link[rel="manifest"]');
        if (manifestLinkEl) {
            const manifestScript = document.getElementById('manifest');
            if (manifestScript) {
                const manifestBlob = new Blob([manifestScript.textContent], {type: 'application/json'});
                const manifestURL = URL.createObjectURL(manifestBlob);
                manifestLinkEl.href = manifestURL;
            }
        }
 <!-- 添加背景音樂 -->
<audio id="bgMusic" loop preload="auto" style="display:none">
    <source src="https://cdn.jsdelivr.net/gh/yoavbln/audios@main/space-atmosphere.mp3" type="audio/mp3">
    您的瀏覽器不支持音頻元素。
</audio>
    </script>
</body>
</html>
