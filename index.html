<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0A0B2F">
    <meta name="description" content="æ˜Ÿç©ºæ¢éšªå®¶ - äº’å‹•å¼å¹¾ä½•å­¸ç¿’éŠæˆ²ï¼Œé€£æ¥æ˜Ÿé»å½¢æˆå„ç¨®å¹¾ä½•å½¢ç‹€æ˜Ÿåº§">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="æ˜Ÿç©ºæ¢éšªå®¶">
    <title>æ˜Ÿç©ºæ¢éšªå®¶ - å¹¾ä½•å­¸ç¿’</title>
    <link rel="manifest" href="#manifest">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNCI+PHJlY3Qgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIgZmlsbD0iIzBBMEIyRiIvPjxwYXRoIGQ9Ik03NjggNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek0yNTYgNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek01MTIgNDQ4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2eiIgZmlsbD0iI0ZGRDcwMCIvPjxwYXRoIGQ9Ik03NjggNTc2YzE4IDAgMzYgMiA1MyA2TDUxMiAyODhjLTEzIDI1LTM0IDQ2LTU5IDU5bDMwOSAyMzVjMS0yIDMtNCA1LTZtMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PHBhdGggZD0iTTQ1OSA0NDhsLTIwMyAyMjRjMjUgMTMgNDYgMzQgNTkgNTlsMjA0LTIyNGMtMjYtMTMtNDgtMzUtNjAtNTltMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PC9zdmc+">
    <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVR4nO3dMUrFQBRA0VdYiYWtpZ/1rEopWLgk38w5+1CBeyHVJQAAAAAAAMDhXa73t+nzfBjAj/l4BAEZ8/EoAjLm41EEZGQ+HkRAZjweRUBGQB5EQGbm43EEZATkQQRkZj4eR0BGQB5EQGbm45EEZMR8PI6AzMzHIwnIzHw8koCMgDyMgIyYj8cRkJn5eCQBGTEfjyMgIyAPI4sMgIAICJhAYQKFCRQ20ljDnBzmDXP2f/wbCUiI+XgcAZkz78/zCEicen9OnUBn35+z79+ZbV6hNq9Qq1eozSvUeXPb5hXKBGrzCmUDtXmFsrVt8wplArU5gdpMoDavULbWNhOozQRqM4HaTKA2EwiAX/M3EJARkAcRkJERkEcRkBHz8TgCMgLyIAIyMx+PIyAjIA8iIDPz8TgCMgLyIAIyMx+PJCAj5uNxBGRmPh5JQGbm45EEZMR8PI6AjIA8jAkUAAAAAAAAAGx8AdzN3SPw43TFAAAAAElFTkSuQmCC">
    <style>
        body {
            background-color: #0A0B2F;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .shape-selector {
            margin-bottom: 20px;
        }
        
        .shape-selector p {
            margin-bottom: 10px;
        }
        
        .shape-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        .shape-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .shape-option input {
            margin-right: 8px;
        }
        
        .shape-name {
            font-size: 16px;
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
            color: #64FFDA;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #0B0E2E, #1A1B4B);
            border-radius: 8px;
            margin: 0 auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #2A2A6A;
            position: relative;
        }
        
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: linear-gradient(135deg, #5D5CDE, #4240B3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(93, 92, 222, 0.4);
        }
        
        button:hover {
            background: linear-gradient(135deg, #6E6DFF, #5250C4);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(93, 92, 222, 0.4);
        }
        
        #checkBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 12px 25px;
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
        }
        
        #checkBtn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(100, 255, 218, 0.5);
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            font-size: 0.8rem;
            padding: 8px 12px;
        }
        
        #hintVisualBtn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.7), rgba(230, 190, 0, 0.7));
            color: #0A0B2F;
        }
        
        #hintVisualBtn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(230, 190, 0, 0.9));
        }
        
        #info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.2), rgba(93, 92, 222, 0.1));
            border-radius: 10px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(93, 92, 222, 0.3);
        }

        #task {
            font-weight: bold;
            color: #64FFDA;
            margin-bottom: 15px;
            line-height: 1.5;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.3);
        }

        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.8));
            padding: 8px 15px;
            border-radius: 20px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64FFDA;
            display: none;
        }

        #hintBox {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1), rgba(100, 255, 218, 0.05));
            border-radius: 8px;
            display: none;
            border: 1px solid rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.1);
        }
        
        .score-container {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #scoreDisplay, #streakDisplay, #highScoreDisplay {
            display: block;
            margin: 3px 0;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #streakDisplay {
            color: #FFD700;
        }
        
        .timer-container {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #timerDisplay {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        .pulse-animation {
            animation: pulse-effect 0.5s;
        }
        
        @keyframes pulse-effect {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-message {
            padding: 12px 20px;
            border-radius: 10px;
            margin-top: 15px;
            display: inline-block;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .result-success {
            background: linear-gradient(135deg, rgba(100, 255, 128, 0.2), rgba(80, 235, 108, 0.2));
            color: #64FFDA;
            border: 1px solid rgba(100, 255, 128, 0.3);
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
        }
        
        .result-fail {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(235, 80, 80, 0.2));
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow: hidden;
        }
        
        #startScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        @keyframes stars-animation {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #startScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #startScreen p {
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.8;
            font-size: 18px;
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #startGameBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        #resultScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
        }
        
        #resultScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        #resultScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #resultScreen p {
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        #finalScore {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            margin: 30px 0 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }
        
        /* æˆå°±ç³»çµ±ç›¸é—œæ¨£å¼ */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(20, 20, 50, 0.6));
            margin: 5px;
            position: relative;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .achievement-badge.unlocked {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(20, 80, 100, 0.3));
            border: 2px solid rgba(100, 255, 218, 0.8);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
            opacity: 1;
            transform: scale(1.05);
        }
        
        .achievement-badge.new-unlock {
            animation: badge-pulse 1.5s infinite alternate;
        }
        
        @keyframes badge-pulse {
            0% { transform: scale(1.05); box-shadow: 0 0 15px rgba(100, 255, 218, 0.5); }
            100% { transform: scale(1.15); box-shadow: 0 0 25px rgba(100, 255, 218, 0.8); }
        }
        
        .achievement-badge .icon {
            font-size: 28px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        .achievement-badge.locked .icon {
            color: rgba(255, 255, 255, 0.4);
            text-shadow: none;
        }
        
        .achievement-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 50, 0.9));
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .achievement-badge:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-popup {
            position: fixed;
            top: 15%;
            right: 10px;
            transform: translateX(100%) scale(0.5);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(20, 20, 80, 0.8));
            padding: 10px 15px;
            border-radius: 12px;
            z-index: 1000;
            text-align: center;
            border: 1px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 200px;
        }
        
        .achievement-popup.show {
            opacity: 0.9;
            transform: translateX(0) scale(1);
        }
        
        .achievement-popup-title {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .achievement-popup-desc {
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .achievement-icon-large {
            font-size: 28px;
            margin: 5px 0;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: achievement-spin 1.5s ease-out;
        }
        
        @keyframes achievement-spin {
            0% { transform: scale(0.5) rotate(-30deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        #achievementsSummary {
            margin-top: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 80, 0.3), rgba(20, 20, 50, 0.2));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        #achievementsSummary h3 {
            font-size: 22px;
            color: #64FFDA;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        #playAgainBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #playAgainBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        .difficulty-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.6), rgba(66, 64, 179, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-row {
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            transition: all 0.3s;
        }
        
        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sound-toggle input {
            margin-right: 8px;
        }
        
        /* Star */
        .star {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                        0 0 20px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .star-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            pointer-events: none;
            opacity: 0;
            animation: star-pulse 2s infinite alternate;
        }
        
        @keyframes star-pulse {
            0% { opacity: 0.1; transform: scale(0.8); }
            100% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Line effect */
        .constellation-line {
            position: absolute;
            background: linear-gradient(90deg, 
                rgba(100, 255, 218, 0) 0%, 
                rgba(100, 255, 218, 0.8) 50%, 
                rgba(100, 255, 218, 0) 100%);
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
            opacity: 0;
            animation: line-appear 0.5s forwards;
        }
        
        @keyframes line-appear {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particles */
        .particle {
            position: absolute;
            background-color: rgba(100, 255, 218, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        /* Floating stars background */
        .bg-stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        
        .bg-star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 4s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .shooting-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.8) 50%, 
                rgba(255, 255, 255, 0) 100%);
            transform: rotate(-45deg);
            animation: shooting 3s linear forwards;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        @keyframes shooting {
            from {
                transform: translateX(0) translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            to {
                transform: translateX(500px) translateY(500px) rotate(-45deg) scale(0.1);
                opacity: 0;
            }
        }
        
        @media (max-width: 500px) {
            button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            #checkBtn {
                padding: 10px 20px;
                font-size: 1rem;
            }
            
            .score-container, .timer-container {
                padding: 3px 10px;
            }
            
            #timerDisplay {
                font-size: 16px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            #task {
                font-size: 16px;
            }
            
            #startScreen h2, #resultScreen h2 {
                font-size: 28px;
            }
            
            #finalScore {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="bg-stars" id="bgStars"></div>
    
    <div id="startScreen">
        <h2>æ˜Ÿç©ºæ¢éšªå®¶ - è¨ˆæ™‚æŒ‘æˆ°æ¨¡å¼</h2>
        <p>åœ¨1åˆ†é˜å…§å®Œæˆç›¡å¯èƒ½å¤šçš„æ˜Ÿåº§å¹¾ä½•æŒ‘æˆ°ï¼<br>é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„å¹¾ä½•æ˜Ÿåº§åœ–å½¢ã€‚</p>
        
        <div class="shape-selector">
            <p>é¸æ“‡æ˜Ÿåº§é¡å‹ï¼š</p>
            <div class="shape-options">
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="triangles" checked>
                    <span class="shape-name">åªç©ä¸‰è§’å½¢æ˜Ÿåº§</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="quadrilaterals">
                    <span class="shape-name">åªç©å››é‚Šå½¢æ˜Ÿåº§</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="all">
                    <span class="shape-name">å…¨éƒ¨æ˜Ÿåº§å½¢ç‹€</span>
                </label>
            </div>
        </div>
        
        <div class="settings-row">
            <label class="sound-toggle">
                <input type="checkbox" id="soundToggle" checked>
                æ˜Ÿç©ºéŸ³æ•ˆ
            </label>
        </div>
        <button id="startGameBtn">é–‹å§‹æ¢ç´¢ä¹‹æ—…</button>
    </div>

    <div id="resultScreen">
        <h2>æ˜Ÿç©ºæ¢éšªçµæŸï¼</h2>
        <p>ä½ åœ¨1åˆ†é˜å…§å®Œæˆäº†ï¼š</p>
        <div id="finalScore">0 å€‹æ˜Ÿåº§</div>
        <p>ç¸½åˆ†ï¼š<span id="finalTotalScore">0</span></p>
        
        <div id="achievementsSummary">
            <h3>è§£é–çš„æ˜Ÿç©ºæ¢éšªå®¶å¾½ç« </h3>
            <div id="achievementsContainer" class="achievement-container"></div>
        </div>
        
        <button id="playAgainBtn">å†æ¬¡æ¢ç´¢</button>
    </div>
    
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon-large">âœ¨</div>
        <div class="achievement-popup-title">è§£é–æˆå°±ï¼</div>
        <div class="achievement-popup-desc">ä½ ç²å¾—äº†ä¸€æšæ–°å¾½ç« </div>
    </div>

    <h1>æ˜Ÿç©ºæ¢éšªå®¶ - æ˜Ÿåº§å¹¾ä½•å­¸ç¿’</h1>
    
    <div id="task">è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§</div>
    
    <div style="position: relative;">
        <div class="timer-container">
            <div id="timerDisplay">01:00</div>
        </div>
        <div class="score-container">
            <span id="scoreDisplay">åˆ†æ•¸: 0</span>
            <span id="streakDisplay">é€£å‹: 0</span>
            <span id="solvedDisplay">å·²è§£é¡Œ: 0</span>
            <span id="difficultyDisplay">é›£åº¦: æ™®é€š</span>
        </div>
        <canvas id="gameCanvas" width="450" height="450"></canvas>
        <div id="tooltip" class="tooltip">é»æ“Šæ­¤æ˜Ÿé»é–‹å§‹é€£ç·š</div>
    </div>
    
    <div id="controls">
        <button id="resetBtn" class="secondary-btn">é‡ç½®æ˜Ÿé»</button>
        <button id="checkBtn">æª¢æŸ¥æ˜Ÿåº§</button>
        <button id="hintTextBtn" class="secondary-btn">æ˜Ÿåº§æç¤º</button>
        <button id="hintVisualBtn" class="secondary-btn">è¦–è¦ºå¹«åŠ©</button>
    </div>
    
    <div id="info">
        <p id="shapeInfo">é€£æ¥é–ƒè€€çš„æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„ä¸‰è§’å½¢æ˜Ÿåº§</p>
        <p id="status">å·²é€£æ¥: 0 æ¢ç·š (éœ€è¦é€£æ¥ 2 æ¢ç·š)</p>
        <div id="hintBox"></div>
        <div id="resultMessage" class="result-message" style="display: none;"></div>
    </div>
    
    <script>
        // ç²å–Canvaså…ƒç´ å’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const hintBox = document.getElementById('hintBox');
        const resultMessage = document.getElementById('resultMessage');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const timerDisplay = document.getElementById('timerDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const soundToggle = document.getElementById('soundToggle');
        const shapeInfo = document.getElementById('shapeInfo');
        const bgStars = document.getElementById('bgStars');
        
        // èƒŒæ™¯æ˜Ÿæ˜Ÿç”Ÿæˆ
        function createBackgroundStars() {
            const starCount = Math.floor(window.innerWidth * window.innerHeight / 1000);
            bgStars.innerHTML = '';
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'bg-star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                const size = Math.random() * 2;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // ä¸åŒçš„é–ƒçˆæ™‚é–“
                star.style.animationDelay = `${Math.random() * 4}s`;
                star.style.animationDuration = `${2 + Math.random() * 3}s`;
                
                // ä¸åŒçš„äº®åº¦
                star.style.opacity = 0.3 + Math.random() * 0.7;
                
                bgStars.appendChild(star);
            }
            
            // æ·»åŠ æµæ˜Ÿ
            createShootingStar();
        }
        
        // æµæ˜Ÿæ•ˆæœ
        function createShootingStar() {
            if (!document.body.contains(bgStars)) return;
            
            const star = document.createElement('div');
            star.className = 'shooting-star';
            
            // éš¨æ©Ÿä½ç½®å’Œå¤§å°
            star.style.left = `${Math.random() * 30}%`;
            star.style.top = `${Math.random() * 20}%`;
            star.style.width = `${80 + Math.random() * 120}px`;
            
            bgStars.appendChild(star);
            
            // å‹•ç•«çµæŸå¾Œç§»é™¤
            setTimeout(() => {
                if (star.parentNode) {
                    star.parentNode.removeChild(star);
                }
                // éš¨æ©Ÿæ™‚é–“å¾Œå†æ¬¡å‡ºç¾
                setTimeout(createShootingStar, 5000 + Math.random() * 15000);
            }, 3000);
        }
        
        // éŠæˆ²è¨­ç½®
        let selectedShapeType = "triangles"; // é»˜èªç‚ºä¸‰è§’å½¢
        let debugMode = false; // å¯åœ¨æ§åˆ¶å°è¨­ç‚ºtrueä»¥é¡¯ç¤ºæ›´å¤šä¿¡æ¯
        let lenientMode = true; // è¼ƒå¯¬é¬†çš„å½¢ç‹€æª¢æ¸¬ï¼Œå› ç‚ºæˆ‘å€‘ä¸æ‡‰è©²å¤ªåš´æ ¼
        
        // éŸ³æ•ˆç³»çµ± - ä½¿ç”¨Web Audio APIåˆæˆéŸ³æ•ˆ
        let audioContext;
        
        // ç‰¹æ•ˆåƒæ•¸
        let stars = [];
        let particles = [];
        let constellationLines = [];
        
        // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.warn('Web Audio API not supported:', e);
            }
        }
        
        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(type) {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // å»ºç«‹éŸ³æ•ˆç¯€é»
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // é€£æ¥ç¯€é»
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // è¨­ç½®ä¸åŒé¡å‹çš„éŸ³æ•ˆåƒæ•¸
                switch(type) {
                    case 'correct':
                        // æ­£ç¢ºéŸ³æ•ˆ - ä¸Šå‡éŸ³
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);  // C5
                        oscillator.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.15); // G5
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'wrong':
                        // éŒ¯èª¤éŸ³æ•ˆ - ä¸‹é™éŸ³
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime);  // G4
                        oscillator.frequency.linearRampToValueAtTime(261.63, audioContext.currentTime + 0.2); // C4
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'connect':
                        // é€£æ¥éŸ³æ•ˆ - çŸ­ä¿ƒæ¸…è„†
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.05); // G5
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    
                    case 'click':
                        // é»æ“ŠéŸ³æ•ˆ - éå¸¸çŸ­ä¿ƒ
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880.00, audioContext.currentTime); // A5
                        oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime + 0.03); // B5
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.08);
                        break;
                        
                    case 'hint':
                        // æç¤ºéŸ³æ•ˆ - ç¥ç§˜çš„ä¸‰å’Œå¼¦
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
            } catch(e) {
                console.warn('Error playing sound:', e);
            }
        }
        
        // ç¶²æ ¼è¨­ç½®
        const gridSize = 50; // æ¯å€‹æ ¼å­çš„å¤§å°
        const numRows = 8;   // è¡Œæ•¸
        const numCols = 8;   // åˆ—æ•¸
        const offsetX = 25;  // Xåç§»ï¼ˆä½¿ç¶²æ ¼å¾é‚Šç·£é–‹å§‹ï¼‰
        const offsetY = 25;  // Yåç§»

        // éŠæˆ²ç‹€æ…‹
        let selectedPoint = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isComplete = false;
        let currentLevelIndex = 0;
        let hoveredPoint = null;
        
        // è¨ˆåˆ†ç³»çµ±
        let score = 0;
        let streak = 0;  // é€£å‹
        let solvedCount = 0; // å·²è§£é¡Œæ•¸
        
        // æˆå°±ç³»çµ±
        const achievements = [
            { id: 'novice', level: 1, name: 'æ˜Ÿéš›æ–°æ‰‹', description: 'å®Œæˆç¬¬ä¸€å€‹æ˜Ÿåº§', icon: 'ğŸŒŸ', unlocked: false },
            { id: 'connector', level: 2, name: 'æ˜Ÿé»é€£æ¥è€…', description: 'å®Œæˆ2å€‹æ˜Ÿåº§', icon: 'â­', unlocked: false },
            { id: 'seeker', level: 3, name: 'æ˜Ÿåº§è¿½å°‹è€…', description: 'å®Œæˆ3å€‹æ˜Ÿåº§', icon: 'âœ¨', unlocked: false },
            { id: 'observer', level: 4, name: 'å¤œç©ºè§€å¯Ÿå®¶', description: 'å®Œæˆ4å€‹æ˜Ÿåº§', icon: 'ğŸ”­', unlocked: false },
            { id: 'apprentice', level: 5, name: 'å¤©æ–‡å­¸å¾’', description: 'å®Œæˆ5å€‹æ˜Ÿåº§', icon: 'ğŸ“š', unlocked: false },
            { id: 'ancient', level: 6, name: 'å¤ä»£å¤©æ–‡å¸«', description: 'å®Œæˆ6å€‹æ˜Ÿåº§', icon: 'ğŸ›ï¸', unlocked: false },
            { id: 'interpreter', level: 7, name: 'æ˜Ÿè±¡è§£è®€å¸«', description: 'å®Œæˆ7å€‹æ˜Ÿåº§', icon: 'ğŸ§™', unlocked: false },
            { id: 'master', level: 8, name: 'æ˜Ÿç©ºæ¢éšªå¤§å¸«', description: 'å®Œæˆ8å€‹æ˜Ÿåº§', icon: 'ğŸ‘‘', unlocked: false }
        ];
        let newUnlocks = [];
        
        // è¨ˆæ™‚ç³»çµ±
        let timeLeft = 60; // 60ç§’
        let timerInterval;
        let isGameActive = false;
        
        // é›£åº¦ç³»çµ±
        let currentDifficulty = "æ™®é€š"; // æ™®é€š, å›°é›£
        
        // é»çš„å¤§å°
        const pointRadius = 7;
        
        // ç”¨æˆ¶é€£æ¥çš„ç·š
        let userLines = [];
        
        // ç²’å­æ•ˆæœç›¸é—œ
        let animationFrameId = null;
        
        // ä¸‰è§’å½¢é—œå¡å®šç¾©
        const triangleLevels = [
            // ç­‰é‚Šä¸‰è§’å½¢ç³»åˆ— - ç²¾ç¢ºè¨ˆç®—çš„ç¶²æ ¼é»
            {
                name: "ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰é‚Šä¸‰è§’å½¢æœ‰ä¸‰æ¢é‚Šç›¸ç­‰ï¼Œæ¯å€‹å…§è§’éƒ½æ˜¯60åº¦ã€‚",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 5, col: 3}, to: {row: 5, col: 5}}, // æ°´å¹³ç·š
                solutionPoint: {row: 3, col: 4}, // ç²¾ç¢ºçš„ç­‰é‚Šä¸‰è§’å½¢é ‚é»
                congratsMessage: "åšå¾—å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰é‚Šä¸‰è§’å½¢æœ‰ä¸‰æ¢é‚Šç›¸ç­‰ï¼Œæ¯å€‹å…§è§’éƒ½æ˜¯60åº¦ã€‚",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 7, col: 5}}, // æ–œç·š
                solutionPoint: {row: 5, col: 1}, // ç²¾ç¢ºçš„ç­‰é‚Šä¸‰è§’å½¢é ‚é»
                congratsMessage: "åšå¾—å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰é‚Šä¸‰è§’å½¢æœ‰ä¸‰æ¢é‚Šç›¸ç­‰ï¼Œæ¯å€‹å…§è§’éƒ½æ˜¯60åº¦ã€‚",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // æ°´å¹³ç·š
                solutionPoint: {row: 1, col: 4}, // ç²¾ç¢ºçš„ç­‰é‚Šä¸‰è§’å½¢é ‚é»
                congratsMessage: "åšå¾—å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // ç­‰è…°ä¸‰è§’å½¢ç³»åˆ— - å¤šç¨®é è¨­ç·š
            {
                name: "ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰è…°ä¸‰è§’å½¢æœ‰å…©æ¢é‚Šç›¸ç­‰ï¼Œè«‹æ‰¾åˆ°èˆ‡è—è‰²ç·šå…©ç«¯ç­‰è·é›¢çš„é»ã€‚",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // æ°´å¹³ç·š
                solutionPoint: {row: 2, col: 4}, // ç¢ºå®šçš„è§£
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰è…°ä¸‰è§’å½¢æœ‰å…©æ¢é‚Šç›¸ç­‰ï¼Œè«‹æ‰¾åˆ°èˆ‡è—è‰²ç·šå…©ç«¯ç­‰è·é›¢çš„é»ã€‚",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 6}}, // å°è§’ç·š
                solutionPoint: {row: 6, col: 2}, // ç¢ºå®šçš„è§£
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç­‰è…°ä¸‰è§’å½¢æœ‰å…©æ¢é‚Šç›¸ç­‰ï¼Œè«‹æ‰¾åˆ°èˆ‡è—è‰²ç·šå…©ç«¯ç­‰è·é›¢çš„é»ã€‚",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // æ–œç·š
                solutionPoint: {row: 2, col: 6}, // ç¢ºå®šçš„è§£
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // ç›´è§’ä¸‰è§’å½¢ç³»åˆ— - ç•¢æ°ä¸‰å…ƒæ•¸
            {
                name: "ç›´è§’ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œæ‰¾åˆ°ä½¿å…©æ¢é‚Šå‚ç›´çš„é»ã€‚",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // æ°´å¹³ç·š
                solutionPoint: {row: 6, col: 6}, // 3:4:5ä¸‰å…ƒæ•¸
                congratsMessage: "éå¸¸å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ç›´è§’ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œæ‰¾åˆ°ä½¿å…©æ¢é‚Šå‚ç›´çš„é»ã€‚",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 4, col: 5}}, // æ°´å¹³ç·š
                solutionPoint: {row: 1, col: 5}, // 3:4:5ä¸‰å…ƒæ•¸
                congratsMessage: "éå¸¸å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ç›´è§’ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œæ‰¾åˆ°ä½¿å…©æ¢é‚Šå‚ç›´çš„é»ã€‚",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 6, col: 6}}, // æ–œç·š
                solutionPoint: {row: 7, col: 2}, // 5:12:13ä¸‰å…ƒæ•¸è®Šé«”
                congratsMessage: "éå¸¸å¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // ç›´è§’ç­‰è…°ä¸‰è§’å½¢ç³»åˆ—
            {
                name: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œå¦å¤–å…©æ¢é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // æ°´å¹³ç·š
                solutionPoint: {row: 7, col: 3}, // å®Œç¾çš„ç›´è§’ç­‰è…°è§£
                congratsMessage: "å¤ªå²å®³äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œå¦å¤–å…©æ¢é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // å‚ç›´ç·š
                solutionPoint: {row: 6, col: 6}, // å®Œç¾çš„ç›´è§’ç­‰è…°è§£
                congratsMessage: "å¤ªå²å®³äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ç›´è§’ç­‰è…°ä¸‰è§’å½¢æœ‰ä¸€å€‹è§’æ˜¯90åº¦ï¼Œå¦å¤–å…©æ¢é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 1, col: 4}}, // æ–œç·š
                solutionPoint: {row: 4, col: 4}, // å®Œç¾çš„ç›´è§’ç­‰è…°è§£
                congratsMessage: "å¤ªå²å®³äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ç›´è§’ç­‰è…°ä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // ä¸ç­‰é‚Šä¸‰è§’å½¢ç³»åˆ—
            {
                name: "ä¸ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ä¸ç­‰é‚Šä¸‰è§’å½¢çš„ä¸‰æ¢é‚Šé•·åº¦å„ä¸ç›¸åŒã€‚",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // æ–œç·š
                solutionPoint: {row: 6, col: 2}, // ç¢ºä¿æ‰€æœ‰é‚Šä¸ç­‰é•·
                congratsMessage: "å„ªç§€ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ä¸ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ä¸ç­‰é‚Šä¸‰è§’å½¢çš„ä¸‰æ¢é‚Šé•·åº¦å„ä¸ç›¸åŒã€‚",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 6}}, // æ–œç·š
                solutionPoint: {row: 7, col: 3}, // ç¢ºä¿æ‰€æœ‰é‚Šä¸ç­‰é•·
                congratsMessage: "å„ªç§€ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "ä¸ç­‰é‚Šä¸‰è§’å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§",
                hint: "ä¸ç­‰é‚Šä¸‰è§’å½¢çš„ä¸‰æ¢é‚Šé•·åº¦å„ä¸ç›¸åŒã€‚",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 4, col: 4}, to: {row: 4, col: 7}}, // æ°´å¹³ç·š
                solutionPoint: {row: 1, col: 2}, // ç¢ºä¿æ‰€æœ‰é‚Šä¸ç­‰é•·
                congratsMessage: "å„ªç§€ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹ä¸ç­‰é‚Šä¸‰è§’å½¢æ˜Ÿåº§ï¼",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            }
        ];
        
        // å››é‚Šå½¢é—œå¡å®šç¾© - å·²ç§»é™¤æ‰€æœ‰æ¢¯å½¢ç›¸é—œé—œå¡
        const quadrilateralLevels = [
            // æ­£æ–¹å½¢ç³»åˆ—
            {
                name: "æ­£æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§",
                hint: "æ­£æ–¹å½¢æœ‰å››æ¢é‚Šç›¸ç­‰ï¼Œå››å€‹è§’éƒ½æ˜¯90åº¦ã€‚",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 6, col: 2}, {row: 6, col: 6}], // æ­£æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "æ­£æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§",
                hint: "æ­£æ–¹å½¢æœ‰å››æ¢é‚Šç›¸ç­‰ï¼Œå››å€‹è§’éƒ½æ˜¯90åº¦ã€‚",
                checkFunction: isSquare,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 7, col: 3}, {row: 7, col: 7}], // æ­£æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "æ­£æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§",
                hint: "æ­£æ–¹å½¢æœ‰å››æ¢é‚Šç›¸ç­‰ï¼Œå››å€‹è§’éƒ½æ˜¯90åº¦ã€‚",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // å‚ç›´ç·š
                solutionPoints: [{row: 2, col: 6}, {row: 6, col: 6}], // æ­£æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¤ªæ£’äº†ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹æ­£æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // é•·æ–¹å½¢ç³»åˆ—
            {
                name: "é•·æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§",
                hint: "é•·æ–¹å½¢æœ‰å››å€‹è§’éƒ½æ˜¯90åº¦ï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRectangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 7}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 5, col: 2}, {row: 5, col: 7}], // é•·æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¾ˆå¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "é•·æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§",
                hint: "é•·æ–¹å½¢æœ‰å››å€‹è§’éƒ½æ˜¯90åº¦ï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRectangle,
                presetLine: {from: {row: 1, col: 1}, to: {row: 6, col: 1}}, // å‚ç›´ç·š
                solutionPoints: [{row: 1, col: 4}, {row: 6, col: 4}], // é•·æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¾ˆå¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "é•·æ–¹å½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§",
                hint: "é•·æ–¹å½¢æœ‰å››å€‹è§’éƒ½æ˜¯90åº¦ï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isRectangle,
                presetLine: {from: {row: 3, col: 1}, to: {row: 3, col: 7}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 7, col: 1}, {row: 7, col: 7}], // é•·æ–¹å½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å¾ˆå¥½ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹é•·æ–¹å½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // å¹³è¡Œå››é‚Šå½¢ç³»åˆ—
            {
                name: "å¹³è¡Œå››é‚Šå½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§",
                hint: "å¹³è¡Œå››é‚Šå½¢æœ‰å…©çµ„å¹³è¡Œçš„å°é‚Šï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 3, col: 2}, to: {row: 3, col: 6}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 6, col: 4}, {row: 6, col: 8}], // å¹³è¡Œå››é‚Šå½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å‡ºè‰²ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "å¹³è¡Œå››é‚Šå½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§",
                hint: "å¹³è¡Œå››é‚Šå½¢æœ‰å…©çµ„å¹³è¡Œçš„å°é‚Šï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 2}}, // å‚ç›´ç·š
                solutionPoints: [{row: 3, col: 6}, {row: 6, col: 6}], // å¹³è¡Œå››é‚Šå½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å‡ºè‰²ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "å¹³è¡Œå››é‚Šå½¢",
                description: "è«‹é€£æ¥æ˜Ÿé»ï¼Œå½¢æˆä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§",
                hint: "å¹³è¡Œå››é‚Šå½¢æœ‰å…©çµ„å¹³è¡Œçš„å°é‚Šï¼Œå°é‚Šç›¸ç­‰ã€‚",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // æ°´å¹³ç·š
                solutionPoints: [{row: 5, col: 4}, {row: 5, col: 8}], // å¹³è¡Œå››é‚Šå½¢çš„å¦å¤–å…©å€‹é»
                congratsMessage: "å‡ºè‰²ï¼ä½ æˆåŠŸå‰µå»ºäº†ä¸€å€‹å¹³è¡Œå››é‚Šå½¢æ˜Ÿåº§ï¼",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            }
        ];
        
        // åˆä½µæ‰€æœ‰é—œå¡
        let levels = [...triangleLevels];
        let currentLevels = [...triangleLevels]; // ç•¶å‰ä½¿ç”¨çš„é—œå¡é›†
        
        // å‹•ç•«å¾ªç’°
        function animate() {
            // æ›´æ–°ç²’å­
            updateParticles();
            
            // ç¹¼çºŒå‹•ç•«å¾ªç’°
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // æ›´æ–°ç²’å­
        function updateParticles() {
            // æ›´æ–°ç²’å­ä½ç½®å’Œç”Ÿå‘½é€±æœŸ
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // æ›´æ–°ä½ç½®
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // æ›´æ–°ç”Ÿå‘½
                particle.life -= 0.02;
                
                // å¦‚æœç²’å­æ­»äº¡ï¼Œç§»é™¤
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                } else {
                    // æ›´æ–°é€æ˜åº¦
                    particle.element.style.opacity = particle.life;
                    
                    // æ›´æ–°ä½ç½®
                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;
                }
            }
            
            // æ›´æ–°æ˜Ÿæ˜Ÿé–ƒçˆæ•ˆæœ
            for (const star of stars) {
                if (Math.random() < 0.005) {
                    const originalScale = parseFloat(star.element.getAttribute('data-scale') || 1);
                    const newScale = originalScale * (0.8 + Math.random() * 0.4);
                    star.element.style.transform = `scale(${newScale})`;
                    
                    setTimeout(() => {
                        if (star.element.parentNode) {
                            star.element.style.transform = `scale(${originalScale})`;
                        }
                    }, 300 + Math.random() * 700);
                }
            }
        }
        
        // å‰µå»ºæ˜Ÿæ˜Ÿæ•ˆæœ
        function createStar(x, y, size = 3, container = document.body) {
            // å‰µå»ºæ˜Ÿæ˜Ÿ
            const star = document.createElement('div');
            star.className = 'star';
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${x}px`;
            star.style.top = `${y}px`;
            star.setAttribute('data-scale', '1');
            
            // å‰µå»ºç™¼å…‰æ•ˆæœ
            const glow = document.createElement('div');
            glow.className = 'star-glow';
            glow.style.width = `${size * 6}px`;
            glow.style.height = `${size * 6}px`;
            glow.style.left = `${x - size * 2.5}px`;
            glow.style.top = `${y - size * 2.5}px`;
            
            // éš¨æ©Ÿé–ƒçˆæ™‚é–“
            glow.style.animationDelay = `${Math.random() * 2}s`;
            
            // æ·»åŠ åˆ°å®¹å™¨
            container.appendChild(star);
            container.appendChild(glow);
            
            return {
                element: star,
                glow: glow,
                x: x,
                y: y,
                size: size
            };
        }
        
        // å‰µå»ºç²’å­
        function createParticle(x, y, color = '#64FFDA') {
            const size = 1 + Math.random() * 2;
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            document.body.appendChild(particle);
            
            // ç²’å­å±¬æ€§
            const particleObj = {
                element: particle,
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: size,
                life: 1 // å¾1æ¸›å°‘åˆ°0
            };
            
            particles.push(particleObj);
            return particleObj;
        }
        
        // å‰µå»ºé€£æ¥ç·šæ•ˆæœ
        function createConstellationLine(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            const line = document.createElement('div');
            line.className = 'constellation-line';
            line.style.width = `${length}px`;
            line.style.left = `${fromX}px`;
            line.style.top = `${fromY}px`;
            line.style.transform = `rotate(${angle}rad)`;
            
            document.body.appendChild(line);
            
            // åœ¨ç·šæ¢ä¸Šæ·»åŠ ç²’å­æ•ˆæœ
            const particleCount = Math.max(5, Math.floor(length / 20));
            for (let i = 0; i < particleCount; i++) {
                const ratio = Math.random();
                const x = fromX + dx * ratio;
                const y = fromY + dy * ratio;
                createParticle(x, y, 'rgba(100, 255, 218, 0.8)');
            }
            
            constellationLines.push(line);
            return line;
        }
        
        // æ¸…é™¤æ•ˆæœå…ƒç´ 
        function clearEffects() {
            // æ¸…é™¤æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                if (star.element.parentNode) star.element.parentNode.removeChild(star.element);
                if (star.glow.parentNode) star.glow.parentNode.removeChild(star.glow);
            });
            stars = [];
            
            // æ¸…é™¤ç²’å­
            particles.forEach(particle => {
                if (particle.element.parentNode) 
                    particle.element.parentNode.removeChild(particle.element);
            });
            particles = [];
            
            // æ¸…é™¤é€£æ¥ç·š
            constellationLines.forEach(line => {
                if (line.parentNode) line.parentNode.removeChild(line);
            });
            constellationLines = [];
            
            // å–æ¶ˆå‹•ç•«
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // å‰µå»ºé€£æ¥ç·š
        function createConnectionLine(fromPoint, toPoint) {
            // è¨ˆç®—ç¶²æ ¼å°ºå¯¸æ¯”ä¾‹å’Œåº§æ¨™
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            const fromX = offsetX + fromPoint.col * gridSize * gridRatio;
            const fromY = offsetY + fromPoint.row * gridSize * gridRatio;
            const toX = offsetX + toPoint.col * gridSize * gridRatio;
            const toY = offsetY + toPoint.row * gridSize * gridRatio;
            
            // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®
            const rect = canvas.getBoundingClientRect();
            
            // å‰µå»ºé€£æ¥ç·šæ•ˆæœ
            createConstellationLine(
                rect.left + fromX, 
                rect.top + fromY, 
                rect.left + toX, 
                rect.top + toY
            );
            
            // åœ¨ç·šè·¯ä¸Šç”Ÿæˆç²’å­æ•ˆæœ
            const particleCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const ratio = i / (particleCount - 1);
                    const x = rect.left + fromX + (toX - fromX) * ratio;
                    const y = rect.top + fromY + (toY - fromY) * ratio;
                    createParticle(x, y);
                }, i * 50);
            }
        }
        
        // åˆå§‹åŒ–éŠæˆ²
        function init() {
            // åˆå§‹åŒ–éŸ³æ•ˆ
            initAudio();
            
            // å‰µå»ºèƒŒæ™¯æ˜Ÿæ˜Ÿ
            createBackgroundStars();
            
            // å•Ÿå‹•å‹•ç•«å¾ªç’°
            animate();
            
            // æ·»åŠ äº‹ä»¶ç›£è½å™¨
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('playAgainBtn').addEventListener('click', restartGame);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // æŒ‰éˆ•äº‹ä»¶
            document.getElementById('resetBtn').addEventListener('click', resetLines);
            document.getElementById('checkBtn').addEventListener('click', checkShape);
            document.getElementById('hintTextBtn').addEventListener('click', toggleTextHint);
            document.getElementById('hintVisualBtn').addEventListener('click', showVisualHint);
            
            // å½¢ç‹€é¸æ“‡äº‹ä»¶
            const shapeOptions = document.querySelectorAll('input[name="shapeType"]');
            shapeOptions.forEach(option => {
                option.addEventListener('change', function() {
                    if (this.checked) {
                        selectedShapeType = this.value;
                    }
                });
            });
            
            // è¦–çª—å¤§å°æ”¹è®Šæ™‚é‡ç•«
            window.addEventListener('resize', () => {
                resizeCanvas();
                createBackgroundStars();
            });
            resizeCanvas();
            
            // é è¼‰å…¥ç¬¬ä¸€é—œä½†ä¸é–‹å§‹éŠæˆ²
            loadLevel(0);
            
            console.log("éŠæˆ²å·²åˆå§‹åŒ–ï¼Œè«‹é»æ“Šã€Œé–‹å§‹æ¢ç´¢ä¹‹æ—…ã€æŒ‰éˆ•é–‹å§‹éŠæˆ²");
        }
        
        // é–‹å§‹éŠæˆ²
        function startGame() {
            startScreen.style.display = 'none';
            
            // æ ¹æ“šé¸æ“‡çš„å½¢ç‹€é¡å‹è¨­ç½®é—œå¡
            setLevelsByShapeType();
            
            // æ›´æ–°é é¢æ¨™é¡Œ
            document.title = `æ˜Ÿç©ºæ¢éšªå®¶ - ${getShapeTypeName()}å­¸ç¿’`;
            document.querySelector('h1').textContent = `æ˜Ÿç©ºæ¢éšªå®¶ - ${getShapeTypeName()}æ˜Ÿåº§å­¸ç¿’`;
            
            // æ›´æ–°ä¿¡æ¯æ–‡å­—
            updateShapeInfoText();
            
            // é‡ç½®éŠæˆ²ç‹€æ…‹
            score = 0;
            streak = 0;
            solvedCount = 0;
            timeLeft = 60;
            isGameActive = true;
            
            // æ¸…ç©ºæ–°è§£é–çš„æˆå°±åˆ—è¡¨
            newUnlocks = [];
            
            // é‡ç½®æˆå°±ç‹€æ…‹
            for (const achievement of achievements) {
                achievement.unlocked = false;
            }
            
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹é—œå¡é–‹å§‹
            loadRandomLevel();
            
            // æ›´æ–°UI
            updateScoreDisplay();
            
            // é‡ç½®é›£åº¦
            currentDifficulty = "æ™®é€š";
            difficultyDisplay.textContent = `é›£åº¦: ${currentDifficulty}`;
            
            // å•Ÿå‹•è¨ˆæ™‚å™¨
            startTimer();
            
            // æ’­æ”¾é–‹å§‹éŸ³æ•ˆ
            playSound('click');
            
            // æ¸…é™¤ç¾æœ‰æ•ˆæœ
            clearEffects();
            
            // é‡å•Ÿå‹•ç•«å¾ªç’°
            if (!animationFrameId) {
                animate();
            }
            
            console.log("éŠæˆ²å·²é–‹å§‹");
        }
        
        // è¨­ç½®é—œå¡æ ¹æ“šå½¢ç‹€é¡å‹
        function setLevelsByShapeType() {
            switch(selectedShapeType) {
                case "triangles":
                    currentLevels = [...triangleLevels];
                    break;
                case "quadrilaterals":
                    currentLevels = [...quadrilateralLevels];
                    break;
                case "all":
                    currentLevels = [...triangleLevels, ...quadrilateralLevels];
                    break;
                default:
                    currentLevels = [...triangleLevels];
            }
            // ç¢ºä¿levelsæ•¸çµ„å¼•ç”¨currentLevelsçš„æ•¸æ“š
            levels = currentLevels;
            
            if (debugMode) {
                console.log(`è¨­ç½®é—œå¡é¡å‹: ${selectedShapeType}`);
                console.log(`ç¸½é—œå¡æ•¸: ${levels.length}`);
            }
        }
        
        // ç²å–å½¢ç‹€é¡å‹åç¨±
        function getShapeTypeName() {
            switch(selectedShapeType) {
                case "triangles": return "ä¸‰è§’å½¢";
                case "quadrilaterals": return "å››é‚Šå½¢";
                case "all": return "å¹¾ä½•å½¢ç‹€";
                default: return "å¹¾ä½•å½¢ç‹€";
            }
        }
        
        // æ›´æ–°å½¢ç‹€ä¿¡æ¯æ–‡å­—
        function updateShapeInfoText() {
            let infoText = "";
            switch(selectedShapeType) {
                case "triangles":
                    infoText = "é€£æ¥é–ƒè€€çš„æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„ä¸‰è§’å½¢æ˜Ÿåº§";
                    break;
                case "quadrilaterals":
                    infoText = "é€£æ¥é–ƒè€€çš„æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„å››é‚Šå½¢æ˜Ÿåº§";
                    break;
                case "all":
                    infoText = "é€£æ¥é–ƒè€€çš„æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„å¹¾ä½•æ˜Ÿåº§";
                    break;
                default:
                    infoText = "é€£æ¥é–ƒè€€çš„æ˜Ÿé»ï¼Œå½¢æˆæŒ‡å®šé¡å‹çš„å¹¾ä½•æ˜Ÿåº§";
            }
            shapeInfo.textContent = infoText;
        }
        
        // é‡æ–°é–‹å§‹éŠæˆ²
        function restartGame() {
            resultScreen.style.display = 'none';
            startGame();
        }
        
        // é¡¯ç¤ºè¦–è¦ºæç¤º
        function showVisualHint() {
            if (!isGameActive) return;
            
            playSound('hint');
            
            const level = levels[currentLevelIndex];
            
            // è¨ˆç®—ç¶²æ ¼å°ºå¯¸æ¯”ä¾‹
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // æ ¹æ“šé—œå¡é¡å‹é¡¯ç¤ºæç¤º
            if (level.type === "triangle") {
                const solutionPoint = level.solutionPoint;
                const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                
                // ç¹ªè£½é–ƒçˆæç¤ºæ•ˆæœ
                ctx.beginPath();
                ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                
                // å‰µå»ºæ¼¸è®Š
                const gradient = ctx.createRadialGradient(
                    x, y, 0, 
                    x, y, pointRadius * 3 * gridRatio
                );
                gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®
                const rect = canvas.getBoundingClientRect();
                
                // å‰µå»ºé–ƒçˆç²’å­æ•ˆæœ
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 30;
                        const px = rect.left + x + Math.cos(angle) * distance;
                        const py = rect.top + y + Math.sin(angle) * distance;
                        createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                    }, i * 100);
                }
            } else if (level.type === "quadrilateral") {
                // å°æ–¼å››é‚Šå½¢ï¼Œé¡¯ç¤ºå…©å€‹è§£é»
                for (const solutionPoint of level.solutionPoints) {
                    const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                    const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                    
                    // ç¹ªè£½é–ƒçˆæç¤ºæ•ˆæœ
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                    
                    // å‰µå»ºæ¼¸è®Š
                    const gradient = ctx.createRadialGradient(
                        x, y, 0, 
                        x, y, pointRadius * 3 * gridRatio
                    );
                    gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                    gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®
                    const rect = canvas.getBoundingClientRect();
                    
                    // å‰µå»ºé–ƒçˆç²’å­æ•ˆæœ
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 30;
                            const px = rect.left + x + Math.cos(angle) * distance;
                            const py = rect.top + y + Math.sin(angle) * distance;
                            createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                        }, i * 100);
                    }
                }
            }
            
            // 2ç§’å¾Œæ¶ˆå¤±
            setTimeout(() => drawGame(), 2000);
        }
        
        // é¡¯ç¤ºæ–‡å­—æç¤º
        function toggleTextHint() {
            if (hintBox.style.display === 'none') {
                hintBox.style.display = 'block';
                playSound('hint');
                
                // æ·»åŠ æ·¡å…¥æ•ˆæœ
                hintBox.style.opacity = 0;
                setTimeout(() => {
                    hintBox.style.transition = 'opacity 0.5s';
                    hintBox.style.opacity = 1;
                }, 10);
            } else {
                // æ·»åŠ æ·¡å‡ºæ•ˆæœ
                hintBox.style.transition = 'opacity 0.5s';
                hintBox.style.opacity = 0;
                
                setTimeout(() => {
                    hintBox.style.display = 'none';
                    hintBox.style.transition = '';
                }, 500);
            }
        }
        
        // å•Ÿå‹•è¨ˆæ™‚å™¨
        function startTimer() {
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                // é–ƒçˆæ•ˆæœç•¶æ™‚é–“å°‘æ–¼10ç§’
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerDisplay.classList.add('pulse-animation');
                    setTimeout(() => timerDisplay.classList.remove('pulse-animation'), 500);
                }
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }
        
        // æ›´æ–°è¨ˆæ™‚å™¨é¡¯ç¤º
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // æ™‚é–“å°‘æ–¼10ç§’æ™‚è®Šç´…
            if (timeLeft <= 10) {
                timerDisplay.style.color = '#FF6464';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 100, 100, 0.7)';
            } else {
                timerDisplay.style.color = '#FFD700';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
            }
        }
        
        // çµæŸéŠæˆ²
        function endGame() {
            clearInterval(timerInterval);
            isGameActive = false;
            
            // æª¢æŸ¥ä¸¦æ›´æ–°æœ€çµ‚æˆå°±
            checkAchievements();
            
            // æ›´æ–°æˆå°±é¡¯ç¤º
            updateAchievementDisplay();
            
            // é¡¯ç¤ºçµæœè¢å¹•
            document.getElementById('finalScore').textContent = `${solvedCount} å€‹æ˜Ÿåº§`;
            document.getElementById('finalTotalScore').textContent = score;
            resultScreen.style.display = 'flex';
            
            // å‰µå»ºæ˜Ÿé»ç²’å­æ•ˆæœ
            const numParticles = Math.min(100, solvedCount * 20);
            for (let i = 0; i < numParticles; i++) {
                setTimeout(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight * 0.7;
                    createParticle(x, y, `hsl(${Math.random() * 60 + 180}, 100%, 70%)`);
                }, i * 20);
            }
            
            // ç‚ºå·²è§£é–çš„æˆå°±æ·»åŠ ç‰¹æ•ˆ
            if (newUnlocks.length > 0) {
                setTimeout(() => {
                    const achievementContainers = document.querySelectorAll('.achievement-badge.new-unlock');
                    achievementContainers.forEach((badge, index) => {
                        // ç‚ºæ¯å€‹æ–°è§£é–çš„æˆå°±å‰µå»ºç™¼å…‰æ•ˆæœ
                        setTimeout(() => {
                            // å‰µå»ºç²’å­æ•ˆæœ
                            const rect = badge.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * 50 + 20;
                                    const x = centerX + Math.cos(angle) * distance;
                                    const y = centerY + Math.sin(angle) * distance;
                                    createParticle(x, y, '#FFD700');
                                }, i * 50);
                            }
                        }, index * 300);
                    });
                }, 500);
            }
            
            console.log("éŠæˆ²çµæŸ");
        }
        
        // éš¨æ©Ÿé¸æ“‡é—œå¡
        function loadRandomLevel() {
            // æ ¹æ“šé€£å‹èª¿æ•´é›£åº¦
            let levelPool = levels;
            
            if (streak >= 5) {
                // å¾é—œå¡ä¸­ç¯©é¸å‡ºå›°é›£çš„
                const hardLevels = levels.filter(l => l.difficulty >= 3);
                if (hardLevels.length > 0) {
                    levelPool = hardLevels;
                    
                    if (currentDifficulty !== "å›°é›£") {
                        currentDifficulty = "å›°é›£";
                        difficultyDisplay.textContent = `é›£åº¦: ${currentDifficulty}`;
                    }
                }
            }
            
            // ç¢ºä¿ä¸é‡è¤‡ä¸Šä¸€å€‹é—œå¡
            let newIndex;
            do {
                if (levelPool.length === 1) {
                    newIndex = 0; // åªæœ‰ä¸€å€‹é—œå¡æ™‚ç›´æ¥é¸æ“‡
                    break;
                }
                
                if (levelPool !== levels) {
                    // å¾å›°é›£é—œå¡ä¸­é¸æ“‡
                    const hardIndex = Math.floor(Math.random() * levelPool.length);
                    // æ‰¾åˆ°åœ¨åŸå§‹é—œå¡é™£åˆ—ä¸­çš„ç´¢å¼•
                    newIndex = levels.findIndex(level => 
                        level.name === levelPool[hardIndex].name && 
                        level.presetLine.from.row === levelPool[hardIndex].presetLine.from.row &&
                        level.presetLine.from.col === levelPool[hardIndex].presetLine.from.col
                    );
                } else {
                    // å¾æ‰€æœ‰é—œå¡ä¸­é¸æ“‡
                    newIndex = Math.floor(Math.random() * levels.length);
                }
            } while (newIndex === currentLevelIndex && levels.length > 1);
            
            currentLevelIndex = newIndex;
            loadLevel(currentLevelIndex);
        }
        
        // èª¿æ•´Canvaså¤§å°
        function resizeCanvas() {
            // ç²å–å®¹å™¨å¤§å°
            const containerWidth = Math.min(450, window.innerWidth - 40);
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerWidth + 'px';
            
            drawGame();
        }
        
        // è¼‰å…¥é—œå¡
        function loadLevel(index) {
            // æ¸…é™¤æ‰€æœ‰æ•ˆæœ
            clearEffects();
            
            currentLevelIndex = index;
            
            if (!levels[currentLevelIndex]) {
                console.error("é—œå¡è¼‰å…¥éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°é—œå¡", index);
                if (levels.length > 0) {
                    currentLevelIndex = 0;
                } else {
                    console.error("æ²’æœ‰å¯ç”¨é—œå¡ï¼");
                    return;
                }
            }
            
            const level = levels[currentLevelIndex];
            
            if (debugMode) {
                console.log(`è¼‰å…¥é—œå¡: ${level.name} (ç´¢å¼•: ${currentLevelIndex})`);
                console.log(`é—œå¡é¡å‹: ${level.type}`);
            }
            
            // æ›´æ–°UI
            document.getElementById('task').textContent = level.description;
            const requiredLines = level.requiredLines || 2; // é»˜èªä¸‰è§’å½¢æ˜¯2æ¢ï¼Œå››é‚Šå½¢æ˜¯3æ¢
            document.getElementById('status').textContent = `å·²é€£æ¥: 0 æ¢ç·š (éœ€è¦é€£æ¥ ${requiredLines} æ¢ç·š)`;
            hintBox.style.display = 'none';
            hintBox.textContent = level.hint;
            
            // éš±è—çµæœè¨Šæ¯
            resultMessage.style.display = 'none';
            
            // é‡ç½®éŠæˆ²ç‹€æ…‹
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            // ç¹ªè£½éŠæˆ²
            drawGame();
            
            // é‡å•Ÿå‹•ç•«å¾ªç’°ï¼ˆå¦‚æœé‚„æ²’å•Ÿå‹•ï¼‰
            if (!animationFrameId) {
                animate();
            }
        }
        
        // ç¹ªè£½éŠæˆ²
        function drawGame() {
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0B0E2E');
            gradient.addColorStop(1, '#1A1B4B');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½èƒŒæ™¯æ˜Ÿæ˜Ÿ - å°é»
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // éš¨æ©Ÿç¨®å­ï¼Œä½¿æ˜Ÿæ˜Ÿä½ç½®ä¿æŒä¸€è‡´
            const levelSeed = currentLevelIndex * 10000;
            const pseudoRandom = (seed) => {
                return ((seed * 9301 + 49297) % 233280) / 233280;
            };
            
            // ç¹ªè£½å°å‹æ˜Ÿæ˜Ÿ
            for (let i = 0; i < 50; i++) {
                const seed = levelSeed + i;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const size = pseudoRandom(seed + 2) * 1.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ç¹ªè£½æ˜Ÿé›²æ•ˆæœ
            ctx.save();
            for (let i = 0; i < 3; i++) {
                const seed = levelSeed + i * 1000;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const radius = 50 + pseudoRandom(seed + 2) * 100;
                
                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(${50 + i * 20}, ${80 + i * 10}, ${150 + i * 20}, 0.03)`);
                nebulaGradient.addColorStop(0.5, `rgba(${40 + i * 20}, ${60 + i * 10}, ${120 + i * 20}, 0.02)`);
                nebulaGradient.addColorStop(1, 'rgba(20, 30, 80, 0)');
                
                ctx.fillStyle = nebulaGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // è¨ˆç®—ç¶²æ ¼å°ºå¯¸æ¯”ä¾‹
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // ç¹ªè£½ç¶²æ ¼ç·šï¼ˆæ·¡ï¼‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // å‚ç›´ç·š
            for (let col = 0; col <= numCols; col++) {
                const x = offsetX + col * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + numRows * gridSize * gridRatio);
                ctx.stroke();
            }
            
            // æ°´å¹³ç·š
            for (let row = 0; row <= numRows; row++) {
                const y = offsetY + row * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + numCols * gridSize * gridRatio, y);
                ctx.stroke();
            }
            
            // é è¨­ç·š
            if (!levels[currentLevelIndex]) return; // é¿å…åˆå§‹åŒ–å•é¡Œ
            
            const level = levels[currentLevelIndex];
            const presetLine = level.presetLine;
            
            // è½‰æ›é è¨­ç·šçš„åº§æ¨™
            const fromX = offsetX + presetLine.from.col * gridSize * gridRatio;
            const fromY = offsetY + presetLine.from.row * gridSize * gridRatio;
            const toX = offsetX + presetLine.to.col * gridSize * gridRatio;
            const toY = offsetY + presetLine.to.row * gridSize * gridRatio;
            
            // ç¹ªè£½é è¨­ç·š
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            
            // ä½¿ç”¨æ¼¸è®Š
            const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            lineGradient.addColorStop(0, '#8A9EFF');
            lineGradient.addColorStop(0.5, '#ADC2FF');
            lineGradient.addColorStop(1, '#8A9EFF');
            
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // æ·»åŠ ç™¼å…‰æ•ˆæœ
            ctx.shadowColor = 'rgba(138, 158, 255, 0.5)';
            ctx.shadowBlur = 10;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // ç§»é™¤é™°å½±ä»¥é˜²å½±éŸ¿å…¶ä»–ç¹ªè£½
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // ç¹ªè£½ç”¨æˆ¶é€£æ¥çš„ç·šæ¢
            for (const line of userLines) {
                const fromX = offsetX + line.from.col * gridSize * gridRatio;
                const fromY = offsetY + line.from.row * gridSize * gridRatio;
                const toX = offsetX + line.to.col * gridSize * gridRatio;
                const toY = offsetY + line.to.row * gridSize * gridRatio;
                
                // è¨ˆç®—ç·šçš„æ¼¸è®Š
                const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
                lineGradient.addColorStop(0, '#64FFDA');
                lineGradient.addColorStop(0.5, '#A0FFE6');
                lineGradient.addColorStop(1, '#64FFDA');
                
                // ç™¼å…‰æ•ˆæœ
                ctx.shadowColor = 'rgba(100, 255, 218, 0.5)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ç§»é™¤é™°å½±
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
            
            // ç¹ªè£½ç•¶å‰æ‹–å‹•çš„ç·š
            if (selectedPoint !== null) {
                const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                
                // æ¼¸è®Šé¡è‰²çš„è™›ç·š
                const dashLineGradient = ctx.createLinearGradient(fromX, fromY, lastMouseX, lastMouseY);
                dashLineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                dashLineGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(lastMouseX, lastMouseY);
                ctx.strokeStyle = dashLineGradient;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // è™›ç·šæ•ˆæœ
                ctx.stroke();
                ctx.setLineDash([]); // é‡ç½®ç‚ºå¯¦ç·š
            }
            
            // å‰µå»ºæ˜Ÿæ˜Ÿæ˜ å°„ï¼Œé¿å…é‡è¤‡å‰µå»º
            const starMap = new Map();
            
            // æ¸…é™¤ç¾æœ‰çš„DOMæ˜Ÿæ˜Ÿ
            clearEffects();
            
            // åˆå§‹åŒ–æ˜Ÿæ˜Ÿé™£åˆ—
            stars = [];
            
            // ç¹ªè£½æ‰€æœ‰ç¶²æ ¼é»
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const x = offsetX + col * gridSize * gridRatio;
                    const y = offsetY + row * gridSize * gridRatio;
                    
                    // ç¢ºå®šé»çš„é¡è‰²å’Œå¤§å°ï¼ˆé è¨­ç·šç«¯é»ã€ç”¨æˆ¶ç·šç«¯é»ã€æ™®é€šé»ï¼‰
                    let isSpecialPoint = false;
                    
                    // æª¢æŸ¥æ˜¯å¦ç‚ºé è¨­ç·šç«¯é»
                    if ((row === presetLine.from.row && col === presetLine.from.col) ||
                        (row === presetLine.to.row && col === presetLine.to.col)) {
                        isSpecialPoint = true;
                    }
                    
                    // æª¢æŸ¥æ˜¯å¦ç‚ºç”¨æˆ¶ç·šç«¯é»
                    for (const line of userLines) {
                        if ((row === line.from.row && col === line.from.col) ||
                            (row === line.to.row && col === line.to.col)) {
                            isSpecialPoint = true;
                            break;
                        }
                    }
                    
                    // æª¢æŸ¥æ˜¯å¦ç‚ºé¸ä¸­æˆ–æ‡¸åœçš„é»
                    const isSelected = selectedPoint && row === selectedPoint.row && col === selectedPoint.col;
                    const isHovered = hoveredPoint && row === hoveredPoint.row && col === hoveredPoint.col;
                    
                    // æ±ºå®šé»çš„ç¹ªè£½æ–¹å¼
                    if (isSpecialPoint || isSelected || isHovered) {
                        // æ˜Ÿé»é–ƒçˆæ•ˆæœ
                        const pulseSize = (Math.sin(Date.now() / 300) * 0.2 + 1);
                        
                        // ç™¼å…‰æ•ˆæœ
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 2 * gridRatio * pulseSize, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(
                            x, y, 0,
                            x, y, pointRadius * 2 * gridRatio * pulseSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // ä¸»æ˜Ÿé»
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        
                        // æ·»åŠ æ˜Ÿå…‰æ•ˆæœ
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.8 * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fill();
                        
                        // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®
                        const rect = canvas.getBoundingClientRect();
                        
                        // åœ¨DOMä¸­å‰µå»ºæ˜Ÿå…‰æ•ˆæœ
                        if (!starMap.has(`${row},${col}`)) {
                            const star = createStar(
                                rect.left + x, 
                                rect.top + y, 
                                pointRadius * 1.5 * gridRatio
                            );
                            stars.push(star);
                            starMap.set(`${row},${col}`, star);
                        }
                    } else {
                        // æ™®é€šé»
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.7 * gridRatio, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fill();
                    }
                    
                    // é¸ä¸­æˆ–æ‡¸åœçš„é»é«˜äº®
                    if (isSelected || isHovered) {
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 1.2 * gridRatio, 0, Math.PI * 2);
                        ctx.strokeStyle = isSelected ? '#ffffff' : 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            // æ›´æ–°ç‹€æ…‹
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `å·²é€£æ¥: ${userLines.length} æ¢ç·š (éœ€è¦é€£æ¥ ${requiredLines} æ¢ç·š)`;
        }
        
        // æŸ¥æ‰¾é»æ“Šä½ç½®çš„ç¶²æ ¼é»
        function findGridPoint(x, y) {
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const pointX = offsetX + col * gridSize * gridRatio;
                    const pointY = offsetY + row * gridSize * gridRatio;
                    
                    const distance = Math.sqrt(
                        Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2)
                    );
                    
                    if (distance <= pointRadius * 2 * gridRatio) {
                        return { row, col };
                    }
                }
            }
            
            return null;
        }
        
        // æª¢æŸ¥æ˜¯å¦å¯ä»¥é€£æ¥å…©å€‹é»
        function canConnectPoints(fromPoint, toPoint) {
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“é€£æ¥
            for (const line of userLines) {
                if ((line.from.row === fromPoint.row && line.from.col === fromPoint.col &&
                     line.to.row === toPoint.row && line.to.col === toPoint.col) ||
                    (line.from.row === toPoint.row && line.from.col === toPoint.col &&
                     line.to.row === fromPoint.row && line.to.col === fromPoint.col)) {
                    return false;
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦èˆ‡é è¨­ç·šé‡è¤‡
            const presetLine = levels[currentLevelIndex].presetLine;
            if ((fromPoint.row === presetLine.from.row && fromPoint.col === presetLine.from.col &&
                 toPoint.row === presetLine.to.row && toPoint.col === presetLine.to.col) ||
                (fromPoint.row === presetLine.to.row && fromPoint.col === presetLine.to.col &&
                 toPoint.row === presetLine.from.row && toPoint.col === presetLine.from.col)) {
                return false;
            }
            
            return true;
        }
        
        // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = `åˆ†æ•¸: ${score}`;
            document.getElementById('streakDisplay').textContent = `é€£å‹: ${streak}`;
            document.getElementById('solvedDisplay').textContent = `å·²è§£é¡Œ: ${solvedCount}`;
        }
        
        // åŠ åˆ†
        function addPoints(points) {
            const scoreDisplay = document.getElementById('scoreDisplay');
            
            // è¨˜éŒ„åŸå§‹åˆ†æ•¸
            const oldScore = score;
            
            // å¢åŠ åˆ†æ•¸
            score += points;
            
            // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
            updateScoreDisplay();
            
            // æ·»åŠ è¦–è¦ºæ•ˆæœ
            scoreDisplay.classList.add('pulse-animation');
            setTimeout(() => {
                scoreDisplay.classList.remove('pulse-animation');
            }, 500);
            
            return score - oldScore; // è¿”å›å¢åŠ çš„åˆ†æ•¸
        }
        
        // æª¢æŸ¥å½¢ç‹€
        function checkShape() {
            if (!isGameActive) return;
            
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2; // é è¨­ç‚ºä¸‰è§’å½¢(2æ¢ç·š)
            
            // æª¢æŸ¥å·²é€£æ¥çš„ç·šæ¢æ•¸é‡
            if (userLines.length !== requiredLines) {
                showResultMessage(`ä½ éœ€è¦é€£æ¥æ°å¥½${requiredLines}æ¢ç·šä¾†å®Œæˆ${level.name}æ˜Ÿåº§ï¼`, false);
                playSound('wrong');
                return;
            }
            
            const result = level.checkFunction();
            
            if (result) {
                handleCorrectShape(level);
            } else {
                // å¤±æ•— - é‡ç½®é€£å‹
                streak = 0;
                updateScoreDisplay();
                
                // æ’­æ”¾éŒ¯èª¤éŸ³æ•ˆ
                playSound('wrong');
                
                // é¡¯ç¤ºå¤±æ•—æ¶ˆæ¯
                showResultMessage("é‚„ä¸æ˜¯æ­£ç¢ºçš„" + level.name + "æ˜Ÿåº§ï¼è«‹å†è©¦ä¸€æ¬¡ã€‚", false);
            }
        }
        
        // è™•ç†æ­£ç¢ºçš„å½¢ç‹€
        function handleCorrectShape(level) {
            // å®Œæˆï¼
            isComplete = true;
            
            // æ’­æ”¾æ­£ç¢ºéŸ³æ•ˆ
            playSound('correct');
            
            // å¢åŠ é€£å‹
            streak++;
            
            // å¢åŠ å·²è§£é¡Œæ•¸
            solvedCount++;
            
            // è¨ˆç®—åˆ†æ•¸ - åŸºæ–¼é›£åº¦å’Œé€£å‹
            const basePoints = level.difficulty * 10;
            const streakBonus = streak > 1 ? streak * 5 : 0;
            const totalPoints = basePoints + streakBonus;
            
            // åŠ åˆ†
            const pointsAdded = addPoints(totalPoints);
            
            // æ›´æ–°ç‹€æ…‹å’Œé¡¯ç¤º
            const statusText = `${level.congratsMessage} +${pointsAdded}åˆ†`;
            showResultMessage(statusText, true);
            
            // æª¢æŸ¥æ˜¯å¦è§£é–æ–°æˆå°±
            checkAchievements();
            
            // å‰µå»ºæ˜Ÿé»é€£æ¥ç‰¹æ•ˆ
            createConnectionEffects();
            
            // æ¼¸è®Šå…‰èŠ’æ•ˆæœ
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å‰µå»ºå®Œæˆç²’å­æ•ˆæœ
            const centerX = rect.left + canvas.width / 2;
            const centerY = rect.top + canvas.height / 2;
            
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * canvas.width * 0.5;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    createParticle(x, y, `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, 255, 0.8)`);
                }, i * 50);
            }
            
            // 1.5ç§’å¾Œè‡ªå‹•é€²å…¥ä¸‹ä¸€é¡Œ
            setTimeout(() => {
                if (isGameActive) {
                    loadRandomLevel();
                }
            }, 1500);
        }
        
        // æª¢æŸ¥æ˜¯å¦è§£é–æˆå°±
        function checkAchievements() {
            // æª¢æŸ¥æ¯å€‹æˆå°±çš„è§£é–æ¢ä»¶
            for (let i = 0; i < achievements.length; i++) {
                const achievement = achievements[i];
                
                if (!achievement.unlocked && solvedCount >= achievement.level) {
                    // è§£é–æˆå°±
                    achievement.unlocked = true;
                    
                    // æ·»åŠ åˆ°æ–°è§£é–åˆ—è¡¨
                    newUnlocks.push(achievement);
                    
                    // é¡¯ç¤ºé€šçŸ¥
                    setTimeout(() => {
                        showAchievementPopup(achievement);
                    }, 500 + i * 1000); // å¦‚æœé€£çºŒè§£é–å¤šå€‹æˆå°±ï¼Œåˆ†é–‹æ™‚é–“é¡¯ç¤º
                }
            }
        }
        
        // é¡¯ç¤ºæˆå°±è§£é–å½ˆçª—
        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            const iconEl = popup.querySelector('.achievement-icon-large');
            const titleEl = popup.querySelector('.achievement-popup-title');
            const descEl = popup.querySelector('.achievement-popup-desc');
            
            // è¨­ç½®å…§å®¹
            iconEl.textContent = achievement.icon;
            titleEl.textContent = `è§£é–æˆå°±ï¼š${achievement.name}`;
            descEl.textContent = achievement.description;
            
            // é¡¯ç¤ºå½ˆçª—
            popup.classList.add('show');
            
            // æ’­æ”¾è§£é–æˆå°±éŸ³æ•ˆ
            playAchievementSound();
            
            // 2ç§’å¾Œéš±è— (ç¸®çŸ­é¡¯ç¤ºæ™‚é–“)
            setTimeout(() => {
                popup.classList.remove('show');
            }, 2000);
        }
        
        // æ’­æ”¾æˆå°±è§£é–éŸ³æ•ˆ
        function playAchievementSound() {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // ç‰¹æ®Šçš„æˆå°±è§£é–éŸ³æ•ˆ - åä¸½çš„ä¸Šå‡éŸ³
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.type = 'sine';
                oscillator2.type = 'triangle';
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // ç¬¬ä¸€å€‹éŸ³èª¿è»Œè·¡
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                oscillator1.frequency.linearRampToValueAtTime(1046.50, audioContext.currentTime + 0.4); // C6
                
                // ç¬¬äºŒå€‹éŸ³èª¿è»Œè·¡ (ç¨å¾®å»¶é²ï¼Œæ·»åŠ å’Œè²æ•ˆæœ)
                oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator2.frequency.linearRampToValueAtTime(987.77, audioContext.currentTime + 0.25); // B5
                oscillator2.frequency.linearRampToValueAtTime(1318.51, audioContext.currentTime + 0.45); // E6
                
                // æ¼¸è®ŠéŸ³é‡
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator1.start();
                oscillator2.start();
                oscillator1.stop(audioContext.currentTime + 0.8);
                oscillator2.stop(audioContext.currentTime + 0.8);
            } catch(e) {
                console.warn('Error playing achievement sound:', e);
            }
        }
        
        // æ›´æ–°æˆå°±é¡¯ç¤º
        function updateAchievementDisplay() {
            const container = document.getElementById('achievementsContainer');
            container.innerHTML = '';
            
            // å…ˆæ·»åŠ æ‰€æœ‰è§£é–çš„æˆå°±
            for (const achievement of achievements) {
                const badge = document.createElement('div');
                badge.className = 'achievement-badge' + (achievement.unlocked ? ' unlocked' : ' locked');
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºæœ¬æ¬¡éŠæˆ²æ–°è§£é–
                if (newUnlocks.includes(achievement)) {
                    badge.classList.add('new-unlock');
                }
                
                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = achievement.icon;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                tooltip.textContent = achievement.unlocked 
                    ? `${achievement.name}: ${achievement.description}` 
                    : `????: å®Œæˆ${achievement.level}å€‹æ˜Ÿåº§è§£é–`;
                
                badge.appendChild(icon);
                badge.appendChild(tooltip);
                container.appendChild(badge);
            }
        }
        
        // å‰µå»ºé€£æ¥ç‰¹æ•ˆ
        function createConnectionEffects() {
            // ç²å–Canvasä½ç½®
            const rect = canvas.getBoundingClientRect();
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // é è¨­ç·šçš„å…©å€‹ç«¯é»
            const presetLine = levels[currentLevelIndex].presetLine;
            const p1 = {
                x: rect.left + offsetX + presetLine.from.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.from.row * gridSize * gridRatio
            };
            const p2 = {
                x: rect.left + offsetX + presetLine.to.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.to.row * gridSize * gridRatio
            };
            
            // å‰µå»ºé è¨­ç·šçš„é€£æ¥æ•ˆæœ
            createConstellationLine(p1.x, p1.y, p2.x, p2.y);
            
            // å‰µå»ºç”¨æˆ¶ç·šçš„é€£æ¥æ•ˆæœ
            for (const line of userLines) {
                const fromX = rect.left + offsetX + line.from.col * gridSize * gridRatio;
                const fromY = rect.top + offsetY + line.from.row * gridSize * gridRatio;
                const toX = rect.left + offsetX + line.to.col * gridSize * gridRatio;
                const toY = rect.top + offsetY + line.to.row * gridSize * gridRatio;
                
                createConstellationLine(fromX, fromY, toX, toY);
            }
        }
        
        // é¡¯ç¤ºçµæœæ¶ˆæ¯
        function showResultMessage(message, isSuccess) {
            resultMessage.textContent = message;
            resultMessage.style.display = 'block';
            
            // è¨­ç½®æ¨£å¼
            resultMessage.className = isSuccess ? 
                'result-message result-success' : 
                'result-message result-fail';
                
            // æ•ˆæœ
            resultMessage.classList.add('pulse-animation');
            setTimeout(() => {
                resultMessage.classList.remove('pulse-animation');
            }, 500);
            
            // æ·»åŠ æ·¡å…¥æ•ˆæœ
            resultMessage.style.opacity = 0;
            setTimeout(() => {
                resultMessage.style.transition = 'opacity 0.3s';
                resultMessage.style.opacity = 1;
            }, 10);
        }
        
        // é‡ç½®ç·šæ¢
        function resetLines() {
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `å·²é€£æ¥: 0 æ¢ç·š (éœ€è¦é€£æ¥ ${requiredLines} æ¢ç·š)`;
            
            // éš±è—çµæœè¨Šæ¯
            resultMessage.style.display = 'none';
            
            // æ’­æ”¾é»æ“ŠéŸ³æ•ˆ
            playSound('click');
            
            // æ¸…é™¤æ•ˆæœ
            clearEffects();
            
            drawGame();
        }
        
        // ç²å–é»é›†åˆï¼ˆåŒ…æ‹¬é è¨­ç·šç«¯é»å’Œç”¨æˆ¶é€£ç·šç«¯é»ï¼‰
        function getShapePoints() {
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2;
            
            if (userLines.length !== requiredLines) return null;
            
            const presetLine = level.presetLine;
            const points = new Set();
            
            // æ·»åŠ é è¨­ç·šçš„å…©å€‹ç«¯é»
            points.add(JSON.stringify(presetLine.from));
            points.add(JSON.stringify(presetLine.to));
            
            // æ·»åŠ ç”¨æˆ¶é€£ç·šçš„æ‰€æœ‰é»
            for (const line of userLines) {
                points.add(JSON.stringify(line.from));
                points.add(JSON.stringify(line.to));
            }
            
            // è½‰æ›å›å°è±¡æ ¼å¼
            const shapePoints = Array.from(points).map(p => JSON.parse(p));
            
            // ä¸‰è§’å½¢éœ€è¦3å€‹é»ï¼Œå››é‚Šå½¢éœ€è¦4å€‹é»
            const expectedPointCount = level.type === "triangle" ? 3 : 4;
            
            if (shapePoints.length !== expectedPointCount) {
                if (debugMode) {
                    console.warn(`é»æ•¸é‡ä¸ç¬¦: æœŸæœ›${expectedPointCount}å€‹é», å¯¦éš›${shapePoints.length}å€‹é»`);
                }
                return null;
            }
            
            return shapePoints;
        }
        
        // ç²å–ä¸‰è§’å½¢çš„ä¸‰å€‹é»
        function getTrianglePoints() {
            if (userLines.length !== 2) return null;
            
            const presetLine = levels[currentLevelIndex].presetLine;
            const presetPoints = [presetLine.from, presetLine.to];
            
            // æ‰¾å‡ºç¬¬ä¸‰å€‹é»ï¼ˆä¸åœ¨é è¨­ç·šä¸Šçš„é»ï¼‰
            let thirdPoint = null;
            
            for (const line of userLines) {
                if (!isPointInArray(line.from, presetPoints)) {
                    thirdPoint = line.from;
                    break;
                }
                if (!isPointInArray(line.to, presetPoints)) {
                    thirdPoint = line.to;
                    break;
                }
            }
            
            if (!thirdPoint) return null;
            
            return {
                p1: presetLine.from,
                p2: presetLine.to,
                p3: thirdPoint
            };
        }
        
        // ç²å–å››é‚Šå½¢çš„å››å€‹é»ï¼ˆæŒ‰ç…§é †æ™‚é‡æˆ–é€†æ™‚é‡é †åºï¼‰
        function getQuadrilateralPoints() {
            const points = getShapePoints();
            if (!points || points.length !== 4) return null;
            
            // æ‰¾å‡ºä¸­å¿ƒé»
            const centerX = points.reduce((sum, p) => sum + p.col, 0) / 4;
            const centerY = points.reduce((sum, p) => sum + p.row, 0) / 4;
            
            // æŒ‰ç…§è§’åº¦æ’åºï¼ˆé †æ™‚é‡æˆ–é€†æ™‚é‡éƒ½å¯ä»¥ï¼‰
            points.sort((a, b) => {
                const angleA = Math.atan2(a.row - centerY, a.col - centerX);
                const angleB = Math.atan2(b.row - centerY, b.col - centerX);
                return angleA - angleB;
            });
            
            if (debugMode) {
                console.log("æ’åºå¾Œçš„å››é‚Šå½¢é ‚é»:", 
                    points.map(p => `(${p.row},${p.col})`).join(' -> '));
            }
            
            // è¿”å›æ’åºå¾Œçš„å››å€‹é»
            return {
                p1: points[0],
                p2: points[1],
                p3: points[2],
                p4: points[3]
            };
        }
        
        // æª¢æŸ¥é»æ˜¯å¦åœ¨æ•¸çµ„ä¸­
        function isPointInArray(point, pointArray) {
            return pointArray.some(p => p.row === point.row && p.col === point.col);
        }
        
        // è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢
        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow((p1.col - p2.col), 2) + 
                Math.pow((p1.row - p2.row), 2)
            );
        }
        
        // è¨ˆç®—æ–œç‡
        function calculateSlope(p1, p2) {
            // é¿å…é™¤ä»¥é›¶çš„æƒ…æ³
            if (p1.col === p2.col) return Infinity;
            return (p1.row - p2.row) / (p1.col - p2.col);
        }
        
        // è¨ˆç®—å‘é‡
        function calculateVector(p1, p2) {
            return {
                x: p2.col - p1.col,
                y: p2.row - p1.row
            };
        }
        
        // è¨ˆç®—å‘é‡çš„é»ç©
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        // è¨ˆç®—å‘é‡çš„æ¨¡ï¼ˆé•·åº¦ï¼‰
        function vectorMagnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        // è¨ˆç®—å…©å€‹å‘é‡ä¹‹é–“çš„è§’åº¦ï¼ˆå¼§åº¦ï¼‰
        function calculateAngle(v1, v2) {
            const dot = dotProduct(v1, v2);
            const mag1 = vectorMagnitude(v1);
            const mag2 = vectorMagnitude(v2);
            
            // é˜²æ­¢é™¤ä»¥é›¶æˆ–è¨ˆç®—èª¤å·®
            if (mag1 === 0 || mag2 === 0) return 0;
            
            // ç¢ºä¿å€¼åœ¨-1åˆ°1ä¹‹é–“ä»¥é¿å…å› è¨ˆç®—èª¤å·®å°è‡´çš„acoséŒ¯èª¤
            const cosTheta = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
            return Math.acos(cosTheta);
        }
        
        // æª¢æŸ¥å…©æ¢ç·šæ˜¯å¦å¹³è¡Œ
        function areLinesParallel(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // å¹³è¡Œå‘é‡çš„å‰ç©ç‚ºé›¶
            const crossProduct = v1.x * v2.y - v1.y * v2.x;
            
            // è€ƒæ…®æµ®é»æ•¸èª¤å·®ï¼Œä½¿ç”¨è¼ƒå¯¬é¬†çš„æ¨™æº–
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(crossProduct) < tolerance;
        }
        
        // æª¢æŸ¥å…©æ¢ç·šæ˜¯å¦å‚ç›´
        function areLinesOrthogonal(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // å‚ç›´å‘é‡çš„é»ç©ç‚ºé›¶
            const dot = dotProduct(v1, v2);
            
            // è€ƒæ…®æµ®é»æ•¸èª¤å·®
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(dot) < tolerance;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºç­‰è…°ä¸‰è§’å½¢
        function isIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // è¨ˆç®—ä¸‰æ¢é‚Šçš„é•·åº¦
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // ä½¿ç”¨è¼ƒåš´æ ¼çš„å®¹å·®
            const tolerance = 0.08; // æ›´åš´æ ¼çš„å®¹å·®ä¾†åˆ¤æ–·ç›¸ç­‰
            const notEqualTolerance = 0.15; // åˆ¤æ–·ä¸ç›¸ç­‰çš„å®¹å·®
            
            // ä½¿ç”¨æ¯”ç‡è€Œä¸æ˜¯çµ•å°å·®å€¼ä¾†è™•ç†è¼ƒå¤§çš„ä¸‰è§’å½¢
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`ç­‰è…°æª¢æ¸¬: é‚Šé•· ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`æ¯”ç‡: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`ç›¸ç­‰é–¾å€¼: ${tolerance}, ä¸ç›¸ç­‰é–¾å€¼: ${notEqualTolerance}`);
            }
            
            // ç­‰è…°ä¸‰è§’å½¢å¿…é ˆæ°å¥½æœ‰å…©æ¢é‚Šç›¸ç­‰ï¼Œç¬¬ä¸‰æ¢é‚Šä¸ç­‰æ–¼å…¶ä»–å…©æ¢
            const sides12Equal = ratio12 < tolerance;
            const sides23Equal = ratio23 < tolerance;
            const sides31Equal = ratio31 < tolerance;
            
            // æª¢æŸ¥æ˜¯å¦ç‚ºç­‰é‚Šä¸‰è§’å½¢ï¼ˆä¸‰æ¢é‚Šéƒ½ç›¸ç­‰ï¼‰
            const isEquilateral = sides12Equal && sides23Equal && sides31Equal;
            
            // è¿”å›trueåªæœ‰åœ¨æ°å¥½å…©æ¢é‚Šç›¸ç­‰ä¸¦ä¸”ä¸æ˜¯ç­‰é‚Šä¸‰è§’å½¢çš„æƒ…æ³
            return !isEquilateral && (
                (sides12Equal && !sides23Equal && !sides31Equal) ||
                (!sides12Equal && sides23Equal && !sides31Equal) ||
                (!sides12Equal && !sides23Equal && sides31Equal)
            );
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºç­‰é‚Šä¸‰è§’å½¢
        function isEquilateralTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // è¨ˆç®—ä¸‰æ¢é‚Šçš„é•·åº¦
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // ä½¿ç”¨æ›´å¯¬é¬†çš„å®¹å·®ï¼Œè®“æ›´å¤šè¦–è¦ºä¸Šæ­£ç¢ºçš„ä¸‰è§’å½¢èƒ½è¢«æ¥å—
            const tolerance = 0.15; // å¢åŠ å®¹å·®åˆ°15%
            
            // ä½¿ç”¨å¤šç¨®æª¢æ¸¬æ–¹æ³•çµåˆåˆ¤æ–·
            
            // æ–¹æ³•1: é‚Šé•·æ¯”ç‡æª¢æ¸¬
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            // è¨ˆç®—æœ€å¤§åå·®
            const maxRatio = Math.max(ratio12, ratio23, ratio31);
            const edgeRatioCheck = maxRatio < tolerance;
            
            // æ–¹æ³•2: è§’åº¦æª¢æ¸¬ (60åº¦è§’æª¢æ¸¬)
            // è¨ˆç®—ä¸‰å€‹å‘é‡
            const v1 = calculateVector(points.p1, points.p2);
            const v2 = calculateVector(points.p2, points.p3);
            const v3 = calculateVector(points.p3, points.p1);
            
            // è¨ˆç®—å¤¾è§’ (ç†æƒ³æƒ…æ³æ˜¯60åº¦ï¼Œå³Ï€/3å¼§åº¦)
            const angle1 = calculateAngle({x: -v3.x, y: -v3.y}, v1);
            const angle2 = calculateAngle({x: -v1.x, y: -v1.y}, v2);
            const angle3 = calculateAngle({x: -v2.x, y: -v2.y}, v3);
            
            // æª¢æŸ¥è§’åº¦æ˜¯å¦æ¥è¿‘60åº¦(Ï€/3)
            const angleTolerance = 0.15; // è§’åº¦å®¹å·®
            const angleCheck = (
                Math.abs(angle1 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle2 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle3 - Math.PI/3) < angleTolerance * Math.PI/3
            );
            
            // æ–¹æ³•3: ä½¿ç”¨é è¨­è§£æ³•æª¢æ¸¬ (æ¯”è¼ƒèˆ‡è§£ç­”é»çš„è¿‘ä¼¼åº¦)
            let solutionCheck = false;
            const level = levels[currentLevelIndex];
            if (level.solutionPoint) {
                // æª¢æŸ¥ç¬¬ä¸‰é»æ˜¯å¦æ¥è¿‘é è¨­çš„è§£ç­”é»
                const solutionDist = calculateDistance(points.p3, level.solutionPoint);
                solutionCheck = solutionDist < 1.5; // å¦‚æœé»åœ¨è§£ç­”é™„è¿‘ï¼Œä¹Ÿèªç‚ºæ­£ç¢º
            }
            
            if (debugMode) {
                console.log(`ç­‰é‚Šæª¢æ¸¬: é‚Šé•· ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`é‚Šé•·æ¯”ç‡: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`æœ€å¤§åå·®: ${maxRatio.toFixed(4)}, é–¾å€¼: ${tolerance}`);
                console.log(`è§’åº¦æª¢æ¸¬: ${angleCheck}, è§£ç­”æª¢æ¸¬: ${solutionCheck}`);
            }
            
            // æ”¾å¯¬æ¨™æº–ï¼šåªè¦æ»¿è¶³é‚Šé•·æ¯”ä¾‹æˆ–è§’åº¦æª¢æ¸¬çš„ä»»ä¸€é …ï¼Œå°±èªç‚ºæ˜¯ç­‰é‚Šä¸‰è§’å½¢
            return edgeRatioCheck || angleCheck || solutionCheck;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºç›´è§’ä¸‰è§’å½¢
        function isRightTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // è¨ˆç®—ä¸‰é‚Šé•·å¹³æ–¹
            const sides = [
                {
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // æª¢æŸ¥ç•¢æ°å®šç† aÂ² + bÂ² = cÂ²
            const tolerance = 0.15; // ä½¿ç”¨è¼ƒå¯¬é¬†çš„å®¹å·®
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            // ä½¿ç”¨å‘é‡æ–¹æ³•é©—è­‰
            const v1 = calculateVector(sides[0].points[0], sides[0].points[1]);
            const v2 = calculateVector(sides[1].points[0], sides[1].points[1]);
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            
            // æ­£äº¤å‘é‡çš„é»ç©æ‡‰æ¥è¿‘æ–¼é›¶
            const orthogonalCheck = Math.abs(dotProduct) / (vectorMagnitude(v1) * vectorMagnitude(v2)) < 0.15;
            
            if (debugMode) {
                console.log(`ç›´è§’æª¢æ¸¬: ç•¢æ°æ¯”ç‡ ${pythagoreanRatio.toFixed(4)}`);
                console.log(`æ­£äº¤æª¢æŸ¥: ${orthogonalCheck}`);
            }
            
            return Math.abs(pythagoreanRatio - 1) < tolerance || orthogonalCheck;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºç›´è§’ç­‰è…°ä¸‰è§’å½¢
        function isRightIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // è¨ˆç®—ä¸‰æ¢é‚Šçš„é•·åº¦å’Œå¹³æ–¹
            const sides = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    length: calculateDistance(points.p3, points.p1),
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // å…©æ¢çŸ­é‚Šçš„æ¯”ä¾‹
            const tolerance = 0.15; // ä½¿ç”¨è¼ƒå¯¬é¬†çš„å®¹å·®
            const isoscelesRatio = Math.abs(sides[0].length - sides[1].length) / Math.max(sides[0].length, sides[1].length);
            
            // ç•¢æ°å®šç†æª¢æŸ¥
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            if (debugMode) {
                console.log(`ç›´è§’ç­‰è…°æª¢æ¸¬: ç­‰è…°æ¯”ç‡ ${isoscelesRatio.toFixed(4)}, ç•¢æ°æ¯”ç‡ ${pythagoreanRatio.toFixed(4)}`);
            }
            
            return isoscelesRatio < tolerance && Math.abs(pythagoreanRatio - 1) < tolerance;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºä¸ç­‰é‚Šä¸‰è§’å½¢
        function isScaleneTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // è¨ˆç®—ä¸‰æ¢é‚Šçš„é•·åº¦
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // æª¢æŸ¥æ‰€æœ‰é‚Šçš„æ¯”ä¾‹ä¸ç›¸ç­‰
            const tolerance = 0.15; // ä½¿ç”¨è¼ƒå¯¬é¬†çš„å®¹å·®
            
            // ä½¿ç”¨æ¯”ç‡æª¢æŸ¥
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`ä¸ç­‰é‚Šæª¢æ¸¬: é‚Šé•· ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`æ¯”ç‡: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
            }
            
            // æ‰€æœ‰é‚Šéƒ½ä¸ç›¸ç­‰ï¼Œä¹Ÿå°±æ˜¯æ²’æœ‰å…©æ¢é‚Šç›¸ç­‰
            return ratio12 > tolerance && ratio23 > tolerance && ratio31 > tolerance;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºæ­£æ–¹å½¢
        function isSquare() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // ç²å–å››é‚Š
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // è¨ˆç®—å°è§’ç·š
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // æª¢æŸ¥æ‰€æœ‰é‚Šæ˜¯å¦åš´æ ¼ç›¸ç­‰ - ä½¿ç”¨æ›´åš´æ ¼çš„å®¹å·®
            const tolerance = 0.06; // æ›´åš´æ ¼çš„å®¹å·®ï¼Œä¸€èˆ¬é•·æ–¹å½¢ä¸æœƒé€šéæ­¤æª¢æŸ¥
            const avgLength = edges.reduce((sum, edge) => sum + edge.length, 0) / 4;
            
            // æª¢æŸ¥æ¯æ¢é‚Šèˆ‡å¹³å‡å€¼çš„åå·®
            const edgeDeviations = edges.map(edge => 
                Math.abs(edge.length - avgLength) / avgLength
            );
            
            const maxDeviation = Math.max(...edgeDeviations);
            const allSidesEqual = maxDeviation < tolerance;
            
            if (debugMode) {
                console.log(`æ­£æ–¹å½¢æª¢æ¸¬ - æœ€å¤§é‚Šé•·åå·®ç‡: ${maxDeviation.toFixed(4)}, é–¾å€¼: ${tolerance}`);
                console.log(`æ­£æ–¹å½¢æª¢æ¸¬ - å››é‚Šé•·åº¦: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // æª¢æŸ¥å°è§’ç·šæ˜¯å¦è¿‘ä¼¼ç›¸ç­‰
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`æ­£æ–¹å½¢æª¢æ¸¬ - å°è§’ç·šæ¯”ç‡: ${diagRatio.toFixed(4)}, é–¾å€¼: ${tolerance}`);
            }
            
            // æª¢æŸ¥ç›¸é„°é‚Šæ˜¯å¦åš´æ ¼å‚ç›´
            const anglesTolerance = 0.08; // æ›´åš´æ ¼çš„è§’åº¦å®¹å·®
            const rightAngles = [
                Math.abs(Math.PI/2 - calculateAngle(edges[0].vector, edges[1].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[1].vector, edges[2].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[2].vector, edges[3].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[3].vector, edges[0].vector))
            ];
            
            const maxAngleDeviation = Math.max(...rightAngles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`æ­£æ–¹å½¢æª¢æ¸¬ - æœ€å¤§è§’åº¦åå·®: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}åº¦, é–¾å€¼: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}åº¦`);
            }
            
            // é€™ä¸‰å€‹æ¢ä»¶å¿…é ˆåŒæ™‚æ»¿è¶³
            return allSidesEqual && diagEqual && hasRightAngles;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºé•·æ–¹å½¢
        function isRectangle() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // ç²å–å››é‚Š
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // å°é‚Šæ‡‰è©²ç›¸ç­‰ï¼Œä½†ç›¸é„°é‚Šå¯èƒ½ä¸ç­‰
            const tolerance = 0.1; // å°é‚Šç›¸ç­‰çš„å®¹å·®
            
            // æª¢æŸ¥å°é‚Šæ˜¯å¦ç›¸ç­‰ï¼ˆç¬¬1ã€3é‚Šç›¸ç­‰ï¼Œç¬¬2ã€4é‚Šç›¸ç­‰ï¼‰
            const ratio13 = Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length);
            const ratio24 = Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length);
            
            const oppositeSidesEqual = ratio13 < tolerance && ratio24 < tolerance;
            
            if (debugMode) {
                console.log(`é•·æ–¹å½¢æª¢æ¸¬ - å°é‚Šæ¯”ç‡: ${ratio13.toFixed(4)}, ${ratio24.toFixed(4)}, é–¾å€¼: ${tolerance}`);
            }
            
            // è¨ˆç®—å°è§’ç·š
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // æª¢æŸ¥å°è§’ç·šæ˜¯å¦ç›¸ç­‰
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`é•·æ–¹å½¢æª¢æ¸¬ - å°è§’ç·šæ¯”ç‡: ${diagRatio.toFixed(4)}, é–¾å€¼: ${tolerance}`);
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ç›´è§’
            const anglesTolerance = 0.08; // æ›´åš´æ ¼çš„è§’åº¦å®¹å·®
            const angles = [
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[0].vector.x, y: -edges[0].vector.y}, 
                    edges[3].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[1].vector.x, y: -edges[1].vector.y}, 
                    edges[0].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[2].vector.x, y: -edges[2].vector.y}, 
                    edges[1].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[3].vector.x, y: -edges[3].vector.y}, 
                    edges[2].vector
                ))
            ];
            
            const maxAngleDeviation = Math.max(...angles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`é•·æ–¹å½¢æª¢æ¸¬ - æœ€å¤§è§’åº¦åå·®: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}åº¦, é–¾å€¼: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}åº¦`);
            }
            
            // é¡å¤–æª¢æŸ¥ï¼šç¢ºä¿ä¸æ˜¯æ­£æ–¹å½¢
            // æª¢æŸ¥ç›¸é„°é‚Šæ˜¯å¦ä¸ç­‰ï¼ˆè‡³å°‘æœ‰ä¸€çµ„ç›¸é„°é‚Šå·®ç•°è¼ƒå¤§ï¼‰
            const adjacentRatio12 = Math.abs(edges[0].length - edges[1].length) / Math.max(edges[0].length, edges[1].length);
            const adjacentRatio23 = Math.abs(edges[1].length - edges[2].length) / Math.max(edges[1].length, edges[2].length);
            const adjacentRatio34 = Math.abs(edges[2].length - edges[3].length) / Math.max(edges[2].length, edges[3].length);
            const adjacentRatio41 = Math.abs(edges[3].length - edges[0].length) / Math.max(edges[3].length, edges[0].length);
            
            // è‡³å°‘æœ‰ä¸€çµ„ç›¸é„°é‚Šå·®ç•°è¼ƒå¤§ï¼ˆä¸æ˜¯æ­£æ–¹å½¢ï¼‰
            const squareTolerance = 0.06; // èˆ‡æ­£æ–¹å½¢åˆ¤æ–·ä¸€è‡´
            const notSquare = adjacentRatio12 > squareTolerance || 
                              adjacentRatio23 > squareTolerance ||
                              adjacentRatio34 > squareTolerance ||
                              adjacentRatio41 > squareTolerance;
            
            if (debugMode) {
                console.log(`é•·æ–¹å½¢æª¢æ¸¬ - éæ­£æ–¹å½¢æª¢æŸ¥: ${notSquare}, ç›¸é„°é‚Šæ¯”ç‡: ${adjacentRatio12.toFixed(4)}, ${adjacentRatio23.toFixed(4)}, ${adjacentRatio34.toFixed(4)}, ${adjacentRatio41.toFixed(4)}`);
            }
            
            // é•·æ–¹å½¢æ¢ä»¶ï¼šå°é‚Šç›¸ç­‰ã€å°è§’ç·šç›¸ç­‰ã€æœ‰ç›´è§’ï¼Œä½†ä¸æ˜¯æ­£æ–¹å½¢
            return oppositeSidesEqual && diagEqual && hasRightAngles && notSquare;
        }
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºå¹³è¡Œå››é‚Šå½¢
        function isParallelogram() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // ç²å–å››é‚Š
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // æª¢æŸ¥å°é‚Šæ˜¯å¦å¹³è¡Œå’Œç›¸ç­‰
            const tolerance = 0.15; // ä½¿ç”¨è¼ƒå¯¬é¬†çš„å®¹å·®
            
            // æª¢æŸ¥å°é‚Šæ˜¯å¦ç›¸ç­‰
            const oppositeSidesEqual = 
                Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length) < tolerance &&
                Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length) < tolerance;
            
            // æª¢æŸ¥å°é‚Šæ˜¯å¦å¹³è¡Œ
            const parallelCheck1 = areLinesParallel(
                points.p1, points.p2,
                points.p3, points.p4
            );
            
            const parallelCheck2 = areLinesParallel(
                points.p2, points.p3,
                points.p4, points.p1
            );
            
            if (debugMode) {
                console.log(`å¹³è¡Œå››é‚Šå½¢æª¢æ¸¬: å°é‚Šç›¸ç­‰ ${oppositeSidesEqual}, å¹³è¡Œæª¢æŸ¥1 ${parallelCheck1}, å¹³è¡Œæª¢æŸ¥2 ${parallelCheck2}`);
                console.log(`é‚Šé•·: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // æª¢æŸ¥æ˜¯å¦æ˜¯é•·æ–¹å½¢æˆ–æ­£æ–¹å½¢
            const isRect = isRectangle();
            const isSq = isSquare();
            
            // æ˜¯å¹³è¡Œå››é‚Šå½¢ä½†ä¸æ˜¯é•·æ–¹å½¢æˆ–æ­£æ–¹å½¢
            return oppositeSidesEqual && parallelCheck1 && parallelCheck2 && !isRect && !isSq;
        }
        
        // æ»‘é¼ äº‹ä»¶è™•ç†
        function handleMouseMove(e) {
            if (!isGameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // æ›´æ–°æ‡¸åœé»
            const previousHovered = hoveredPoint;
            hoveredPoint = findGridPoint(x, y);
            
            // å¦‚æœæ‡¸åœé»ç™¼ç”Ÿè®ŠåŒ–ï¼Œæ·»åŠ æ˜Ÿæ˜Ÿé–ƒçˆå‹•ç•«
            if (hoveredPoint && (!previousHovered || 
                previousHovered.row !== hoveredPoint.row || 
                previousHovered.col !== hoveredPoint.col)) {
                playSound('click');
                
                // ç•¶æ‡¸åœåˆ°æ–°é»æ™‚ï¼Œå¯ä»¥æ·»åŠ ç²’å­æ•ˆæœ
                const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                const pointX = offsetX + hoveredPoint.col * gridSize * gridRatio;
                const pointY = offsetY + hoveredPoint.row * gridSize * gridRatio;
                
                // æ·»åŠ å¾®å¼±çš„ç²’å­æ•ˆæœ
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 15;
                        createParticle(
                            rect.left + pointX + Math.cos(angle) * distance, 
                            rect.top + pointY + Math.sin(angle) * distance
                        );
                    }, i * 50);
                }
            }
            
            // æ›´æ–°æ‹–å‹•ç·šçš„çµ‚é»
            if (selectedPoint !== null) {
                lastMouseX = x;
                lastMouseY = y;
            }
            
            // æ›´æ–°å·¥å…·æç¤º
            updateTooltip(e);
            
            drawGame();
        }
        
        function updateTooltip(e) {
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                
                if (selectedPoint === null) {
                    tooltip.textContent = 'é»æ“Šæ­¤æ˜Ÿé»é–‹å§‹é€£ç·š';
                } else if (hoveredPoint.row === selectedPoint.row && hoveredPoint.col === selectedPoint.col) {
                    tooltip.textContent = 'å–æ¶ˆé¸æ“‡æ­¤æ˜Ÿé»';
                } else if (canConnectPoints(selectedPoint, hoveredPoint)) {
                    tooltip.textContent = 'é€£æ¥åˆ°æ­¤æ˜Ÿé»';
                } else {
                    tooltip.textContent = 'å·²ç¶“é€£æ¥éé€™å…©é»';
                }
                
                // æ¼¸è®Šå‡ºç¾æ•ˆæœ
                tooltip.style.opacity = 0;
                tooltip.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    tooltip.style.opacity = 1;
                }, 10);
            } else {
                tooltip.style.opacity = 0;
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 300);
            }
        }
        
        function handleMouseDown(e) {
            if (!isGameActive || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // å–æ¶ˆé¸æ“‡
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // é¸æ“‡ç¬¬ä¸€å€‹é»
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®å’Œåº§æ¨™
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // é¸æ“‡é»æ™‚çš„ç²’å­æ•ˆæœ
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // é€£æ¥åˆ°ç¬¬äºŒå€‹é»
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // ç²å–é»åº§æ¨™
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    const toX = offsetX + gridPoint.col * gridSize * gridRatio;
                    const toY = offsetY + gridPoint.row * gridSize * gridRatio;
                    
                    // å‰µå»ºé€£æ¥æ•ˆæœ
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // ç²å–ç•¶å‰é—œå¡æ‰€éœ€çš„ç·šæ¢æ•¸
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // è‡ªå‹•æª¢æ¸¬ - å¦‚æœå®Œæˆæ‰€éœ€ç·šæ¢æ•¸
                    if (userLines.length === requiredLines) {
                        // çŸ­æš«å»¶é²è®“ç”¨æˆ¶çœ‹åˆ°å®Œæˆçš„å½¢ç‹€
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleMouseUp(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // é€£æ¥åˆ°ç¬¬äºŒå€‹é»
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // å‰µå»ºé€£æ¥æ•ˆæœ
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // ç²å–ç•¶å‰é—œå¡æ‰€éœ€çš„ç·šæ¢æ•¸
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // è‡ªå‹•æª¢æ¸¬ - å¦‚æœå®Œæˆæ‰€éœ€ç·šæ¢æ•¸
                if (userLines.length === requiredLines) {
                    // çŸ­æš«å»¶é²è®“ç”¨æˆ¶çœ‹åˆ°å®Œæˆçš„å½¢ç‹€
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // è§¸æ§äº‹ä»¶è™•ç†
        function handleTouchStart(e) {
            if (!isGameActive || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // å–æ¶ˆé¸æ“‡
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // é¸æ“‡ç¬¬ä¸€å€‹é»
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // ç²å–Canvasç›¸å°æ–¼è¦–çª—çš„ä½ç½®å’Œåº§æ¨™
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // é¸æ“‡é»æ™‚çš„ç²’å­æ•ˆæœ
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // é€£æ¥åˆ°ç¬¬äºŒå€‹é»
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // å‰µå»ºé€£æ¥æ•ˆæœ
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // ç²å–ç•¶å‰é—œå¡æ‰€éœ€çš„ç·šæ¢æ•¸
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // è‡ªå‹•æª¢æ¸¬ - å¦‚æœå®Œæˆæ‰€éœ€ç·šæ¢æ•¸
                    if (userLines.length === requiredLines) {
                        // çŸ­æš«å»¶é²è®“ç”¨æˆ¶çœ‹åˆ°å®Œæˆçš„å½¢ç‹€
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleTouchMove(e) {
            if (!isGameActive || selectedPoint === null || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastMouseX = touch.clientX - rect.left;
            lastMouseY = touch.clientY - rect.top;
            
            // æ›´æ–°æ‡¸åœé»
            hoveredPoint = findGridPoint(lastMouseX, lastMouseY);
            
            drawGame();
        }
        
        function handleTouchEnd(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = lastMouseX;
                y = lastMouseY;
            }
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // é€£æ¥åˆ°ç¬¬äºŒå€‹é»
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // å‰µå»ºé€£æ¥æ•ˆæœ
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // ç²å–ç•¶å‰é—œå¡æ‰€éœ€çš„ç·šæ¢æ•¸
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // è‡ªå‹•æª¢æ¸¬ - å¦‚æœå®Œæˆæ‰€éœ€ç·šæ¢æ•¸
                if (userLines.length === requiredLines) {
                    // çŸ­æš«å»¶é²è®“ç”¨æˆ¶çœ‹åˆ°å®Œæˆçš„å½¢ç‹€
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // åœ¨æ§åˆ¶å°å•Ÿç”¨debugæ¨¡å¼çš„æ–¹æ³•
        window.enableDebug = function() {
            debugMode = true;
            console.log("èª¿è©¦æ¨¡å¼å·²å•Ÿç”¨");
        };
        
        window.disableDebug = function() {
            debugMode = false;
            console.log("èª¿è©¦æ¨¡å¼å·²ç¦ç”¨");
        };
        
        // åˆå§‹åŒ–éŠæˆ²
        window.onload = init;
    </script>
    <!-- MindCrafter ç½²å -->
    <div style="text-align: center; margin-top: 15px; margin-bottom: 10px; font-size: 14px; opacity: 0.7;">
        <span style="color: #64FFDA;">@ MindCrafter</span>
    </div>
    
    <!-- PWA å®‰è£æŒ‰éˆ• -->
    <div id="installContainer" style="display: none; position: fixed; bottom: 20px; left: 20px; z-index: 900;">
        <button id="installBtn" style="background: linear-gradient(135deg, #64FFDA, #00D0B6); color: #0A0B2F; padding: 10px 15px; border: none; border-radius: 30px; font-weight: bold; box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4); display: flex; align-items: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" style="margin-right: 8px; fill: #0A0B2F;">
                <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
            </svg>
            å®‰è£æ‡‰ç”¨
        </button>
    </div>

    <!-- PWA manifest -->
    <script id="manifest" type="application/manifest+json">
    {
      "name": "æ˜Ÿç©ºæ¢éšªå®¶",
      "short_name": "æ˜Ÿç©ºæ¢éšª",
      "description": "äº’å‹•å¼å¹¾ä½•å­¸ç¿’éŠæˆ²ï¼Œé€£æ¥æ˜Ÿé»å½¢æˆå„ç¨®å¹¾ä½•å½¢ç‹€æ˜Ÿåº§",
      "start_url": "./",
      "display": "standalone",
      "background_color": "#0A0B2F",
      "theme_color": "#0A0B2F",
      "orientation": "portrait",
      "icons": [
        {
          "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDEwMjQgMTAyNCI+PHJlY3Qgd2lkdGg9IjEwMjQiIGhlaWdodD0iMTAyNCIgZmlsbD0iIzBBMEIyRiIvPjxwYXRoIGQ9Ik03NjggNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek0yNTYgNzY4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2ek01MTIgNDQ4YzUzIDAgOTYtNDMgOTYtOTZzLTQzLTk2LTk2LTk2LTk2IDQzLTk2IDk2IDQzIDk2IDk2IDk2eiIgZmlsbD0iI0ZGRDcwMCIvPjxwYXRoIGQ9Ik03NjggNTc2YzE4IDAgMzYgMiA1MyA2TDUxMiAyODhjLTEzIDI1LTM0IDQ2LTU5IDU5bDMwOSAyMzVjMS0yIDMtNCA1LTZtMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PHBhdGggZD0iTTQ1OSA0NDhsLTIwMyAyMjRjMjUgMTMgNDYgMzQgNTkgNTlsMjA0LTIyNGMtMjYtMTMtNDgtMzUtNjAtNTltMCAwIiBzdHJva2U9IiM2NEZGREEiIHN0cm9rZS13aWR0aD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IjIwLDIwIi8+PC9zdmc+",
          "sizes": "512x512",
          "type": "image/svg+xml"
        }
      ]
    }
    </script>

    <!-- Service worker è¨»å†Š -->
    <script>
        // æª¢æŸ¥æ˜¯å¦æ”¯æ´ Service Worker API
        if ('serviceWorker' in navigator) {
            // åœ¨é é¢è¼‰å…¥å®Œæˆå¾Œè¨»å†Š service worker
            window.addEventListener('load', function() {
                // å‰µå»º blob URL ç”¨æ–¼ service worker
                const swScript = `
                    const CACHE_NAME = 'star-explorer-v1';
                    const urlsToCache = [
                        './',
                        './index.html'
                    ];

                    // å®‰è£ service worker æ™‚å¿«å–å¿…è¦è³‡æº
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    console.log('Cache opened');
                                    return cache.addAll(urlsToCache);
                                })
                        );
                    });

                    // æ””æˆªç¶²è·¯è«‹æ±‚
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => {
                                    // å¦‚æœå¿«å–ä¸­æœ‰å°æ‡‰çš„è³‡æºï¼Œå‰‡ç›´æ¥è¿”å›
                                    if (response) {
                                        return response;
                                    }
                                    
                                    // è¤‡è£½è«‹æ±‚ï¼Œä»¥ä¾¿åœ¨å¾ŒçºŒä½¿ç”¨
                                    const fetchRequest = event.request.clone();
                                    
                                    // å˜—è©¦å¾ç¶²è·¯ç²å–è³‡æº
                                    return fetch(fetchRequest)
                                        .then(response => {
                                            if (!response || response.status !== 200 || response.type !== 'basic') {
                                                return response;
                                            }
                                            
                                            // è¤‡è£½éŸ¿æ‡‰
                                            const responseToCache = response.clone();
                                            
                                            // å°‡éŸ¿æ‡‰æ·»åŠ åˆ°å¿«å–
                                            caches.open(CACHE_NAME)
                                                .then(cache => {
                                                    cache.put(event.request, responseToCache);
                                                });
                                                
                                            return response;
                                        });
                                })
                                .catch(() => {
                                    // å¦‚æœç„¡æ³•ç²å–è³‡æºä¸¦ä¸”ä¹Ÿä¸åœ¨å¿«å–ä¸­ï¼Œè¿”å›é›¢ç·šé é¢æˆ–å…¶ä»–å›é€€å…§å®¹
                                    return new Response('No internet connection. Please try again later.');
                                })
                        );
                    });

                    // ç•¶æ–°çš„ service worker å–å¾—æ§åˆ¶æ¬Šæ™‚ï¼Œåˆ·æ–°å¿«å–
                    self.addEventListener('activate', event => {
                        const cacheWhitelist = [CACHE_NAME];
                        
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheWhitelist.indexOf(cacheName) === -1) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                    });
                `;
                
                const blob = new Blob([swScript], {type: 'application/javascript'});
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // è™•ç† PWA å®‰è£åŠŸèƒ½
        let deferredPrompt;
        const installContainer = document.getElementById('installContainer');
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            // é˜»æ­¢ Chrome é»˜èªçš„å®‰è£æç¤º
            e.preventDefault();
            // ä¿å­˜äº‹ä»¶ä»¥ä¾¿ç¨å¾Œèª¿ç”¨
            deferredPrompt = e;
            // é¡¯ç¤ºè‡ªå®šç¾©å®‰è£æŒ‰éˆ•
            installContainer.style.display = 'block';
        });

        installBtn.addEventListener('click', (e) => {
            // éš±è—å®‰è£æŒ‰éˆ•
            installContainer.style.display = 'none';
            // é¡¯ç¤ºå®‰è£æç¤º
            deferredPrompt.prompt();
            // ç­‰å¾…ç”¨æˆ¶å›æ‡‰
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('ç”¨æˆ¶æ¥å—äº†å®‰è£æ‡‰ç”¨');
                } else {
                    console.log('ç”¨æˆ¶æ‹’çµ•äº†å®‰è£æ‡‰ç”¨');
                }
                deferredPrompt = null;
            });
        });

        window.addEventListener('appinstalled', (evt) => {
            // è¨˜éŒ„æ‡‰ç”¨å®‰è£æˆåŠŸ
            console.log('æ‡‰ç”¨å®‰è£æˆåŠŸ');
        });

        // å¾ URL ä¸­å‰µå»ºå…§è¯ Manifest
        const manifestLinkEl = document.querySelector('link[rel="manifest"]');
        if (manifestLinkEl) {
            const manifestScript = document.getElementById('manifest');
            if (manifestScript) {
                const manifestBlob = new Blob([manifestScript.textContent], {type: 'application/json'});
                const manifestURL = URL.createObjectURL(manifestBlob);
                manifestLinkEl.href = manifestURL;
            }
        }
 <!-- æ·»åŠ èƒŒæ™¯éŸ³æ¨‚ -->
<audio id="bgMusic" loop preload="auto" style="display:none">
    <source src="https://cdn.jsdelivr.net/gh/yoavbln/audios@main/space-atmosphere.mp3" type="audio/mp3">
    æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒéŸ³é »å…ƒç´ ã€‚
</audio>
    </script>
</body>
</html>
